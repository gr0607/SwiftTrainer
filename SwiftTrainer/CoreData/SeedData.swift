//
//  SendData.swift
//  SwiftTrainer
//
//

import CoreData

typealias questionForBase = [(question: String, answers: [String], correctIndex: Int16, hint: String)]


let categories: [String] = [
    "Swift",
    "UIKit",
    "SwiftUI",
    "Store Data",
    "Networking",
    "Concurrency"
]

let subcategories: [String: [String]] = [
    "Swift": ["Типы данных", "Операторы", "Условные конструкции", "Циклы", "Функции", "Классы и структуры", "Протоколы"],
    "UIKit": ["UIView", "UIViewController", "UITableView", "UICollectionView", "Авто-Layout", "Gesture Recognizers"],
    "SwiftUI": ["View", "Modifiers", "State и Binding", "NavigationView", "List и ForEach", "Stacks и Layouts"],
    "Store Data": ["UserDefaults", "FileManager", "Core Data", "Codable", "Keychain"],
    "Networking": ["URLSession", "JSON Parsing", "REST API", "WebSockets", "Alamofire"],
    "Concurrency": ["DispatchQueue", "OperationQueue", "Async/Await", "Task", "Actors"]
]

// Вопросы Swift 11
let dataTypeQuestions: questionForBase = [
    ( "Какой тип данных в Swift используется для хранения целых чисел?",
      ["Int", "Double", "String", "Float"],
      0, // правильный ответ "Int"
      "Целые числа всегда сохраняются в Int." ),

    ( "Какой тип данных в Swift используется для хранения текста?",
      ["Character", "String", "Int", "Bool"],
      1, // правильный ответ "String"
      "Строки текста всегда работают через String." ),

    ( "Какой тип данных хранит значение true/false?",
      ["Bool", "Int", "String", "Double"],
      0,
      "Логические значения всегда в Bool." ),

    ( "Какой тип данных хранит число с плавающей точкой двойной точности?",
      ["Float", "Double", "Int", "Decimal"],
      1,
      "Double — стандарт для чисел с плавающей точкой." ),

    ( "Какой тип данных хранит один символ?",
      ["String", "Character", "Int", "Unicode"],
      1,
      "Один символ — это Character." ),

    ( "Какой тип данных хранит маленькие числа с плавающей точкой?",
      ["Int", "Double", "Float", "Decimal"],
      2,
      "Float используется для экономии памяти." ),

    ( "Что вернёт выражение type(of: 42)?",
      ["String", "Int.Type", "Int", "Number"],
      2,
      "42 — это Int." ),

    ( "Какой тип данных лучше использовать для валюты?",
      ["Double", "Decimal", "Float", "Int"],
      1,
      "Decimal лучше подходит для финансов." ),

    ( "Можно ли создать собственный тип данных в Swift?",
      ["Нет", "Да, с помощью классов и структур", "Только через enum", "Только через protocol"],
      1,
      "Да, создаём через class или struct." ),

    ( "Какой тип данных используется для хранения Unicode-строки?",
      ["UTF8", "String", "Character", "Text"],
      1,
      "String хранит Unicode-строки." )
] //1
let extensionQuestions: questionForBase = [
    (
        question: "Что такое расширение (extension) в Swift?",
        answers: [
            "Способ добавить новое поведение существующему типу",
            "Новый тип данных",
            "Метод наследования",
            "Способ копирования объектов"
        ],
        correctIndex: 0,
        hint: "Расширение — это добавление функциональности к уже существующему типу"
    ),
    (
        question: "Могут ли расширения добавлять новые методы в существующие типы?",
        answers: [
            "Да",
            "Нет",
            "Только для классов",
            "Только для структур"
        ],
        correctIndex: 0,
        hint: "Методы — это как раз основное, что удобно добавлять через extensions"
    ),
    (
        question: "Можно ли в расширении добавлять вычисляемые свойства?",
        answers: [
            "Да, только вычисляемые",
            "Да, любые",
            "Нет",
            "Только для enum"
        ],
        correctIndex: 0,
        hint: "Хранить данные extension не может, но вычисляемые свойства допустимы"
    ),
    (
        question: "Можно ли расширением добавить хранимое свойство?",
        answers: [
            "Да",
            "Нет",
            "Да, но только для классов",
            "Да, но только для структур"
        ],
        correctIndex: 1,
        hint: "Extensions не позволяют добавлять stored properties"
    ),
    (
        question: "Можно ли расширением добавить инициализаторы?",
        answers: [
            "Да",
            "Нет",
            "Только convenience init",
            "Только required init"
        ],
        correctIndex: 0,
        hint: "Да, но без stored properties это ограничено"
    ),
    (
        question: "Могут ли расширения добавлять соответствие протоколу?",
        answers: [
            "Да",
            "Нет",
            "Только для классов",
            "Только для enum"
        ],
        correctIndex: 0,
        hint: "Через extensions удобно подписывать типы под протоколы"
    ),
    (
        question: "Можно ли в расширении добавлять вложенные типы?",
        answers: [
            "Да",
            "Нет",
            "Только структуры",
            "Только классы"
        ],
        correctIndex: 0,
        hint: "В extension можно определить вложенный enum, struct или class"
    ),
    (
        question: "Можно ли использовать extensions для разделения кода на логические блоки?",
        answers: [
            "Да",
            "Нет",
            "Только в playground",
            "Только в generic типах"
        ],
        correctIndex: 0,
        hint: "Это частая практика — разбивать код по расширениям"
    ),
    (
        question: "Как называется расширение, добавляющее реализацию методов протокола?",
        answers: [
            "Default implementation",
            "Static extension",
            "Protocol class",
            "Override"
        ],
        correctIndex: 0,
        hint: "Речь о дефолтных реализациях методов протоколов"
    ),
    (
        question: "Можно ли расширением ограничить доступ к существующему методу?",
        answers: [
            "Нет",
            "Да",
            "Только для public методов",
            "Только для private методов"
        ],
        correctIndex: 0,
        hint: "Extensions могут только добавлять, но не ограничивать или изменять"
    )
] //2
let methodsAndFunctionsQuestions: questionForBase = [
    (
        question: "Что такое функция в Swift?",
        answers: [
            "Фрагмент кода, выполняющий определённую задачу",
            "Класс с методами",
            "Объект с состоянием",
            "Тип данных"
        ],
        correctIndex: 0,
        hint: "Функция — это независимый блок кода"
    ),
    (
        question: "Чем метод отличается от функции?",
        answers: [
            "Метод принадлежит типу, а функция существует сама по себе",
            "Функция быстрее метода",
            "Метод всегда возвращает значение",
            "Разницы нет"
        ],
        correctIndex: 0,
        hint: "Метод всегда связан с типом (структурой, классом, enum)"
    ),
    (
        question: "Можно ли указывать имена параметров в функции?",
        answers: [
            "Да, внешние и внутренние",
            "Нет",
            "Только для первого параметра",
            "Только для возвращаемого значения"
        ],
        correctIndex: 0,
        hint: "В Swift у параметров могут быть внешние и внутренние имена"
    ),
    (
        question: "Что означает ключевое слово mutating в методах структур?",
        answers: [
            "Метод может изменять свойства структуры",
            "Метод нельзя вызвать",
            "Метод становится статическим",
            "Метод доступен только внутри модуля"
        ],
        correctIndex: 0,
        hint: "По умолчанию методы структур не могут изменять свойства"
    ),
    (
        question: "Можно ли функции в Swift возвращать несколько значений?",
        answers: [
            "Да, с помощью кортежей",
            "Нет",
            "Да, но только массив",
            "Да, но только словарь"
        ],
        correctIndex: 0,
        hint: "Для этого используется tuple — кортеж"
    ),
    (
        question: "Что такое функция высшего порядка?",
        answers: [
            "Функция, принимающая или возвращающая другую функцию",
            "Функция с приоритетом выполнения",
            "Функция с рекурсией",
            "Главная функция программы"
        ],
        correctIndex: 0,
        hint: "Например, map, filter и reduce — функции высшего порядка"
    ),
    (
        question: "Можно ли определять вложенные функции?",
        answers: [
            "Да",
            "Нет",
            "Только в классах",
            "Только в протоколах"
        ],
        correctIndex: 0,
        hint: "Функция внутри функции доступна только в её области видимости"
    ),
    (
        question: "Что означает ключевое слово static у метода?",
        answers: [
            "Метод принадлежит типу, а не экземпляру",
            "Метод нельзя переопределить",
            "Метод выполняется быстрее",
            "Метод становится приватным"
        ],
        correctIndex: 0,
        hint: "Static методы вызываются через сам тип, а не через объект"
    ),
    (
        question: "Можно ли в методе класса переопределить метод суперкласса?",
        answers: [
            "Да, с помощью override",
            "Нет",
            "Да, но только private методы",
            "Да, но только статические методы"
        ],
        correctIndex: 0,
        hint: "Для переопределения используется override"
    ),
    (
        question: "Можно ли у функции быть безымянным параметром?",
        answers: [
            "Да, если использовать символ _",
            "Нет",
            "Только для методов классов",
            "Только для возвращаемых значений"
        ],
        correctIndex: 0,
        hint: "Символ _ позволяет убрать внешнее имя параметра"
    )
] //3
let propertiesQuestions: questionForBase = [
    (
        question: "Что такое stored properties (хранимые свойства)?",
        answers: [
            "Свойства, которые сохраняют значения в экземпляре класса или структуры",
            "Свойства, вычисляемые при каждом обращении",
            "Свойства, доступные только в протоколах",
            "Свойства, которые существуют только во время выполнения функции"
        ],
        correctIndex: 0,
        hint: "Stored properties реально хранят данные в объекте"
    ),
    (
        question: "Что такое computed properties (вычисляемые свойства)?",
        answers: [
            "Свойства, которые обязательно используют lazy",
            "Свойства, возвращающие значение через getter и/или setter",
            "Свойства, которые не могут иметь тип",
            "Свойства, доступные только в классах"
        ],
        correctIndex: 1,
        hint: "Они не хранят значение, а вычисляют при обращении"
    ),
    (
        question: "Какое ключевое слово используется для ленивого свойства?",
        answers: [
            "weak",
            "static",
            "lazy",
            "final"
        ],
        correctIndex: 2,
        hint: "Это свойство инициализируется только при первом обращении"
    ),
    (
        question: "Где можно использовать свойство willSet?",
        answers: [
            "Только у stored properties",
            "У stored и computed properties",
            "Только у классов",
            "Нигде, оно устарело"
        ],
        correctIndex: 0,
        hint: "willSet и didSet применяются только к хранимым свойствам"
    ),
    (
        question: "Что делает ключевое слово weak у свойства?",
        answers: [
            "Создаёт сильную ссылку",
            "Создаёт слабую ссылку, которая не удерживает объект",
            "Создаёт глобальное свойство",
            "Создаёт статическое свойство"
        ],
        correctIndex: 1,
        hint: "weak используется для избежания retain cycle"
    ),
    (
        question: "Можно ли у структуры использовать lazy свойства?",
        answers: [
            "Нет, только у классов",
            "Да, но только var, а не let",
            "Да, но только для static",
            "Нет, только для enum"
        ],
        correctIndex: 1,
        hint: "У структур lazy свойства должны быть изменяемыми (var)"
    ),
    (
        question: "Что произойдёт, если обратиться к optional свойству, равному nil?",
        answers: [
            "Программа упадёт с ошибкой",
            "Вернётся nil, если используется optional chaining",
            "Вернётся пустое значение по умолчанию",
            "Свойство автоматически инициализируется"
        ],
        correctIndex: 1,
        hint: "Optional chaining безопасно вернёт nil без краша"
    ),
    (
        question: "Что такое static property?",
        answers: [
            "Свойство, доступное только экземплярам",
            "Свойство, общее для всех экземпляров",
            "Свойство, доступное только внутри метода",
            "Свойство, которое всегда lazy"
        ],
        correctIndex: 1,
        hint: "Static принадлежит типу, а не объекту"
    ),
    (
        question: "В чём разница между let и var при объявлении свойства?",
        answers: [
            "let создаёт изменяемое свойство, var — нет",
            "let создаёт константу, var — изменяемое свойство",
            "let можно использовать только в классах",
            "var доступно только в структурах"
        ],
        correctIndex: 1,
        hint: "let делает свойство неизменяемым"
    ),
    (
        question: "Можно ли у свойства сделать приватный setter?",
        answers: [
            "Нет",
            "Да, с помощью private(set)",
            "Только в структурах",
            "Только в протоколах"
        ],
        correctIndex: 1,
        hint: "private(set) ограничивает изменение свойства только внутри типа"
    )
] //4
let collectionsQuestions: questionForBase = [
    (
        question: "Какой тип коллекции в Swift является упорядоченным и может содержать дубликаты?",
        answers: [
            "Array",
            "Set",
            "Dictionary",
            "Tuple"
        ],
        correctIndex: 0,
        hint: "Array — это упорядоченная коллекция, допускающая одинаковые элементы"
    ),
    (
        question: "Какой тип коллекции хранит только уникальные значения?",
        answers: [
            "Array",
            "Set",
            "Dictionary",
            "Optional"
        ],
        correctIndex: 1,
        hint: "Set автоматически убирает дубликаты"
    ),
    (
        question: "Какой тип коллекции хранит пары ключ–значение?",
        answers: [
            "Array",
            "Set",
            "Dictionary",
            "Stack"
        ],
        correctIndex: 2,
        hint: "Dictionary сопоставляет ключ с соответствующим значением"
    ),
    (
        question: "Что вернёт обращение к несуществующему ключу в Dictionary?",
        answers: [
            "Ошибка во время выполнения",
            "Nil",
            "Пустую строку",
            "0"
        ],
        correctIndex: 1,
        hint: "Если ключа нет, Dictionary возвращает nil"
    ),
    (
        question: "Какой метод используется для добавления элемента в Array?",
        answers: [
            "insert(_:at:)",
            "add(_:)",
            "append(_:)",
            "push(_:)"
        ],
        correctIndex: 2,
        hint: "append добавляет элемент в конец массива"
    ),
    (
        question: "Что произойдёт, если попытаться добавить дубликат в Set?",
        answers: [
            "Будет ошибка компиляции",
            "Будет ошибка выполнения",
            "Элемент просто не добавится",
            "Set превратится в Array"
        ],
        correctIndex: 2,
        hint: "Set хранит только уникальные значения"
    ),
    (
        question: "Как получить количество элементов в коллекции?",
        answers: [
            "count",
            "size",
            "length",
            "capacity"
        ],
        correctIndex: 0,
        hint: "Все коллекции в Swift имеют свойство count"
    ),
    (
        question: "Можно ли изменять Array, объявленный как let?",
        answers: [
            "Да, всегда",
            "Нет, никогда",
            "Да, если это var внутри структуры",
            "Да, но только если массив изменяемый (var), а let запрещает это"
        ],
        correctIndex: 1,
        hint: "let делает сам массив неизменяемым"
    ),
    (
        question: "Как удалить все элементы из Array?",
        answers: [
            "remove(at:)",
            "removeLast()",
            "clear()",
            "removeAll()"
        ],
        correctIndex: 3,
        hint: "removeAll() очищает массив"
    ),
    (
        question: "Можно ли использовать разные типы значений в одном Array?",
        answers: [
            "Да, если объявить массив как [Any]",
            "Нет, Swift запрещает это",
            "Да, но только для чисел",
            "Да, но только для строк"
        ],
        correctIndex: 0,
        hint: "[Any] позволяет хранить элементы разных типов"
    )
] //5
let genericsQuestions: questionForBase = [
    (
        question: "Для чего используются дженерики в Swift?",
        answers: [
            "Для создания кода, работающего с разными типами",
            "Для ускорения выполнения кода",
            "Для хранения только строк",
            "Для создания многопоточности"
        ],
        correctIndex: 0,
        hint: "Дженерики позволяют писать универсальный код для разных типов"
    ),
    (
        question: "Как обозначается параметр типа в дженериках по умолчанию?",
        answers: [
            "T",
            "X",
            "Type",
            "Element"
        ],
        correctIndex: 0,
        hint: "Чаще всего используется T (Type), но это может быть любое имя"
    ),
    (
        question: "Можно ли ограничить дженерик так, чтобы он работал только с типами, реализующими протокол?",
        answers: [
            "Нет",
            "Да, с помощью where или двоеточия",
            "Да, только для классов",
            "Да, но только для структур"
        ],
        correctIndex: 1,
        hint: "Пример: func test<T: Equatable>(value: T)"
    ),
    (
        question: "Что означает запись func swapTwoValues<T>(_ a: inout T, _ b: inout T)?",
        answers: [
            "Функция может менять местами только Int",
            "Функция может менять местами значения любого типа",
            "Функция работает только со строками",
            "Функция использует наследование"
        ],
        correctIndex: 1,
        hint: "Здесь T — универсальный тип, значит функция работает с любыми типами"
    ),
    (
        question: "Что может использоваться как параметр дженерика?",
        answers: [
            "Только классы",
            "Только структуры",
            "Любой тип (классы, структуры, перечисления)",
            "Только протоколы"
        ],
        correctIndex: 2,
        hint: "Дженерики работают с любыми типами данных"
    ),
    (
        question: "Какой ключевой оператор используется для добавления ограничений в дженериках?",
        answers: [
            "where",
            "if",
            "guard",
            "case"
        ],
        correctIndex: 0,
        hint: "Ограничения указываются через where"
    ),
    (
        question: "Можно ли создавать собственные обобщённые типы?",
        answers: [
            "Нет, только функции могут быть дженериками",
            "Да, можно делать обобщённые классы, структуры и перечисления",
            "Да, но только классы",
            "Да, но только структуры"
        ],
        correctIndex: 1,
        hint: "В Swift можно создавать обобщённые классы, структуры и перечисления"
    ),
    (
        question: "Что такое associatedtype в протоколах?",
        answers: [
            "Типовое ограничение для дженерика",
            "Способ создать абстрактный тип, который будет уточнён при реализации",
            "Метод, работающий с массивами",
            "Аналог наследования классов"
        ],
        correctIndex: 1,
        hint: "associatedtype позволяет отложить определение типа до момента реализации протокола"
    ),
    (
        question: "Как можно указать, что дженерик должен работать только с классами?",
        answers: [
            "T: Any",
            "T: AnyObject",
            "T: Class",
            "T: NSObject"
        ],
        correctIndex: 1,
        hint: "Ограничение T: AnyObject делает параметр типа ссылочным"
    ),
    (
        question: "Что происходит при использовании дженериков с производительностью?",
        answers: [
            "Код работает медленнее",
            "Производительность почти не страдает",
            "Swift запрещает использовать дженерики в продакшене",
            "Компилятор всегда оптимизирует их под Int"
        ],
        correctIndex: 1,
        hint: "Компилятор Swift подставляет конкретные типы, поэтому производительность остаётся высокой"
    )
] //6
let inheritanceQuestions: questionForBase = [
    (
        question: "Что такое наследование в Swift?",
        answers: [
            "Механизм передачи свойств и методов от одного класса к другому",
            "Способ хранения данных в массиве",
            "Создание копии структуры",
            "Метод для обработки ошибок"
        ],
        correctIndex: 0,
        hint: "Наследование используется только для классов и позволяет создавать иерархии"
    ),
    (
        question: "Какой базовый класс используется по умолчанию в Swift?",
        answers: [
            "NSObject",
            "BaseClass",
            "Нет базового класса",
            "Any"
        ],
        correctIndex: 2,
        hint: "В Swift классы не наследуются от какого-то универсального класса автоматически"
    ),
    (
        question: "Какие типы в Swift поддерживают наследование?",
        answers: [
            "Только классы",
            "Структуры и классы",
            "Перечисления",
            "Все типы"
        ],
        correctIndex: 0,
        hint: "Структуры и перечисления не поддерживают наследование"
    ),
    (
        question: "Какой ключевое слово используется для наследования?",
        answers: [
            "extends",
            "inherits",
            "super",
            ":"
        ],
        correctIndex: 3,
        hint: "Пример: class Dog: Animal { }"
    ),
    (
        question: "Как вызвать метод суперкласса внутри переопределённого метода?",
        answers: [
            "parent.method()",
            "super.method()",
            "base.method()",
            "this.method()"
        ],
        correctIndex: 1,
        hint: "Ключевое слово super указывает на базовый класс"
    ),
    (
        question: "Какой модификатор нужен для того, чтобы метод можно было переопределить?",
        answers: [
            "required",
            "override",
            "final",
            "open"
        ],
        correctIndex: 1,
        hint: "Методы должны быть переопределены с ключевым словом override"
    ),
    (
        question: "Что делает модификатор final у класса?",
        answers: [
            "Запрещает наследование от этого класса",
            "Запрещает создавать экземпляры класса",
            "Запрещает изменять свойства",
            "Делает класс абстрактным"
        ],
        correctIndex: 0,
        hint: "final запрещает наследование"
    ),
    (
        question: "Что произойдет, если не вызвать инициализатор суперкласса?",
        answers: [
            "Код не скомпилируется",
            "Swift вызовет его автоматически всегда",
            "Будет выполнен только инициализатор подкласса",
            "Создастся пустой объект"
        ],
        correctIndex: 0,
        hint: "Swift требует явного вызова designated initializer суперкласса"
    ),
    (
        question: "Можно ли наследоваться от нескольких классов одновременно?",
        answers: [
            "Да, как в C++",
            "Нет, только от одного класса",
            "Да, но только если это протоколы",
            "Только для структур"
        ],
        correctIndex: 1,
        hint: "Swift поддерживает только одиночное наследование"
    ),
    (
        question: "Какой модификатор доступа позволяет наследование вне модуля?",
        answers: [
            "public",
            "open",
            "internal",
            "fileprivate"
        ],
        correctIndex: 1,
        hint: "open — самый открытый уровень доступа для классов и методов"
    )
] //7
let structsAndClassesQuestions: questionForBase = [
    (
        question: "В чём основное отличие структур от классов в Swift?",
        answers: [
            "Структуры — типы ссылочные, классы — типы значимые",
            "Структуры — типы значимые, классы — ссылочные",
            "Они ничем не отличаются",
            "Классы быстрее структур"
        ],
        correctIndex: 1,
        hint: "Структуры передаются по значению, классы — по ссылке"
    ),
    (
        question: "Можно ли в структурах определять методы?",
        answers: [
            "Нет, только в классах",
            "Да, но только статические",
            "Да, можно определять обычные и статические методы",
            "Нет, методы доступны только в протоколах"
        ],
        correctIndex: 2,
        hint: "Методы можно определять и в структурах"
    ),
    (
        question: "Каким словом объявляется структура в Swift?",
        answers: [
            "class",
            "struct",
            "enum",
            "data"
        ],
        correctIndex: 1,
        hint: "Используется ключевое слово struct"
    ),
    (
        question: "Что поддерживают классы, но не поддерживают структуры?",
        answers: [
            "Инициализаторы",
            "Наследование",
            "Свойства",
            "Методы"
        ],
        correctIndex: 1,
        hint: "Наследование доступно только классам"
    ),
    (
        question: "Какие типы коллекций в Swift реализованы как структуры?",
        answers: [
            "Array, Dictionary, Set",
            "NSArray, NSDictionary",
            "List, Map",
            "Vector, HashMap"
        ],
        correctIndex: 0,
        hint: "Базовые коллекции Swift реализованы как структуры"
    ),
    (
        question: "Что произойдет при передаче структуры в функцию?",
        answers: [
            "Передастся ссылка на объект",
            "Передастся копия структуры",
            "Произойдет ошибка",
            "Передастся пустой объект"
        ],
        correctIndex: 1,
        hint: "Структуры передаются по значению (копия)"
    ),
    (
        question: "Что общего у структур и классов?",
        answers: [
            "Оба поддерживают свойства и методы",
            "Оба поддерживают наследование",
            "Оба поддерживают только статические методы",
            "Оба поддерживают множественное наследование"
        ],
        correctIndex: 0,
        hint: "Структуры и классы могут содержать свойства и методы"
    ),
    (
        question: "Можно ли структуры расширять с помощью extensions?",
        answers: [
            "Нет, только классы расширяются",
            "Да, структуры тоже можно расширять",
            "Только в отдельных модулях",
            "Нет, это зарезервировано для протоколов"
        ],
        correctIndex: 1,
        hint: "Расширения работают и для структур"
    ),
    (
        question: "Какое ключевое слово нужно для создания экземпляра класса или структуры?",
        answers: [
            "create",
            "init",
            "new",
            "Никакого, просто ()"
        ],
        correctIndex: 3,
        hint: "Пример: let user = User()"
    ),
    (
        question: "Где по умолчанию хранятся экземпляры классов?",
        answers: [
            "В куче (heap)",
            "В стеке (stack)",
            "В регистре процессора",
            "В файле"
        ],
        correctIndex: 0,
        hint: "Классы — ссылочные типы и размещаются в куче"
    )
] //8
let initDeinitQuestions: questionForBase = [
    (
        question: "Что такое инициализатор в Swift?",
        answers: ["Метод для освобождения памяти", "Метод для установки начального состояния объекта", "Функция глобальной области", "Метод для удаления объекта"],
        correctIndex: 1,
        hint: "Инициализаторы задают начальные значения свойств объекта."
    ),
    (
        question: "Каким ключевым словом объявляется инициализатор?",
        answers: ["func", "init", "deinit", "class"],
        correctIndex: 1,
        hint: "Ключевое слово очень короткое, всего 4 буквы."
    ),
    (
        question: "Может ли структура в Swift иметь инициализаторы?",
        answers: ["Нет, только классы имеют инициализаторы", "Да, структуры тоже могут иметь инициализаторы", "Только через протокол", "Только через extension"],
        correctIndex: 1,
        hint: "Инициализаторы поддерживаются и классами, и структурами."
    ),
    (
        question: "Для чего используется деинициализатор?",
        answers: ["Для освобождения ресурсов перед удалением объекта", "Для инициализации свойств", "Для создания объекта", "Для вызова методов"],
        correctIndex: 0,
        hint: "Срабатывает в момент удаления экземпляра."
    ),
    (
        question: "Каким ключевым словом объявляется деинициализатор?",
        answers: ["delete", "init", "deinit", "destroy"],
        correctIndex: 2,
        hint: "Это сокращённое слово от 'de-initialize'."
    ),
    (
        question: "Может ли структура иметь деинициализатор?",
        answers: ["Да", "Нет", "Только если реализует протокол", "Только если содержит reference type"],
        correctIndex: 1,
        hint: "Деинициализаторы работают только у классов."
    ),
    (
        question: "Можно ли перегружать инициализаторы в Swift?",
        answers: ["Нет", "Да, можно определять несколько инициализаторов", "Только один init на класс", "Только через наследование"],
        correctIndex: 1,
        hint: "Можно создавать init с разными параметрами."
    ),
    (
        question: "Что такое convenience инициализатор?",
        answers: ["Основной инициализатор класса", "Вспомогательный инициализатор, вызывающий designated init", "Инициализатор для структур", "Специальный деинициализатор"],
        correctIndex: 1,
        hint: "Он всегда вызывает designated initializer."
    ),
    (
        question: "Когда вызывается деинициализатор?",
        answers: ["При создании объекта", "Когда объект удаляется из памяти", "Когда объект изменяет свойства", "Вручную при вызове destroy()"],
        correctIndex: 1,
        hint: "Деинициализатор вызывается системой автоматически."
    ),
    (
        question: "Можно ли напрямую вызвать деинициализатор?",
        answers: ["Да, через объект.deinit()", "Нет, он вызывается автоматически", "Только в наследовании", "Через специальную функцию"],
        correctIndex: 1,
        hint: "У программиста нет прямого доступа к вызову деинициализатора."
    )
] //9
let errorHandlingQuestions: questionForBase = [
    (
        question: "Какое ключевое слово используется для обозначения функции, которая может выбросить ошибку?",
        answers: ["throwable", "throws", "error", "catch"],
        correctIndex: 1,
        hint: "Оно ставится после сигнатуры функции."
    ),
    (
        question: "Каким оператором вызывается функция, которая может выбросить ошибку?",
        answers: ["try", "catch", "throw", "do"],
        correctIndex: 0,
        hint: "Его всегда пишут перед вызовом функции."
    ),
    (
        question: "Что делает оператор `throw` в Swift?",
        answers: ["Определяет ошибку", "Создает исключение", "Выбрасывает ошибку", "Завершает программу"],
        correctIndex: 2,
        hint: "Он используется для генерации ошибки."
    ),
    (
        question: "Какой блок используется для обработки ошибок?",
        answers: ["if-else", "switch", "do-catch", "guard"],
        correctIndex: 2,
        hint: "Он похож на try-catch из других языков."
    ),
    (
        question: "Что произойдет, если ошибка не будет обработана?",
        answers: ["Код продолжит выполнение", "Программа завершится с ошибкой", "Ошибка автоматически исправится", "Ничего не произойдет"],
        correctIndex: 1,
        hint: "Swift требует явной обработки ошибок."
    ),
    (
        question: "Для чего используется `try?`?",
        answers: ["Преобразует ошибку в nil", "Принудительно обрабатывает ошибку", "Выбрасывает ошибку", "Создает ошибку"],
        correctIndex: 0,
        hint: "Возвращает опциональное значение."
    ),
    (
        question: "Для чего используется `try!`?",
        answers: ["Игнорирует возможность ошибки", "Выбрасывает ошибку", "Создает error object", "Обрабатывает ошибку в блоке catch"],
        correctIndex: 0,
        hint: "Если ошибка произойдет – приложение упадет."
    ),
    (
        question: "Что должна реализовать ошибка в Swift?",
        answers: ["Протокол Error", "Протокол Throwable", "Класс Exception", "Интерфейс Fail"],
        correctIndex: 0,
        hint: "В Swift используется специальный пустой протокол."
    ),
    (
        question: "Можно ли использовать `switch` для обработки ошибок?",
        answers: ["Нет", "Да, если ошибка является enum", "Только в do-catch", "Только через guard"],
        correctIndex: 1,
        hint: "Обычно ошибки делают через перечисления."
    ),
    (
        question: "Что делает конструкция `defer` при работе с ошибками?",
        answers: ["Отменяет выполнение блока", "Откладывает выполнение кода до выхода из области видимости", "Завершает программу", "Выбрасывает ошибку"],
        correctIndex: 1,
        hint: "Код внутри нее выполняется в конце, даже при ошибках."
    )
] //10
let protocolQuestions: questionForBase = [
    (
        question: "Какое ключевое слово используется для объявления протокола в Swift?",
        answers: ["interface", "protocol", "delegate", "abstract"],
        correctIndex: 1,
        hint: "Очень похоже на название самой темы."
    ),
    (
        question: "Могут ли протоколы наследовать другие протоколы?",
        answers: ["Нет", "Да", "Только один", "Только если они классовые"],
        correctIndex: 1,
        hint: "Swift позволяет множественное наследование протоколов."
    ),
    (
        question: "Что может содержать протокол?",
        answers: ["Только свойства", "Только методы", "Свойства и методы", "Только классы"],
        correctIndex: 2,
        hint: "Протокол описывает требования к типу."
    ),
    (
        question: "Можно ли в протоколе указывать требования к свойствам?",
        answers: ["Нет", "Да, но только к вычисляемым", "Да, можно к любым", "Да, только к stored свойствам"],
        correctIndex: 2,
        hint: "Протокол описывает наличие свойства, но не его реализацию."
    ),
    (
        question: "Как объявить, что структура или класс соответствует протоколу?",
        answers: ["Через ключевое слово conform", "После двоеточия", "Через оператор ->", "С помощью use"],
        correctIndex: 1,
        hint: "Синтаксис такой же, как при наследовании."
    ),
    (
        question: "Что такое optional методы в протоколах?",
        answers: ["Методы, которые можно не реализовывать", "Методы с nil внутри", "Методы для работы с опционалами", "Методы для классов"],
        correctIndex: 0,
        hint: "Они доступны только в протоколах с @objc."
    ),
    (
        question: "Можно ли ограничить протокол только для классов?",
        answers: ["Нет", "Да, с помощью AnyObject", "Да, с помощью class-only", "Только для final классов"],
        correctIndex: 1,
        hint: "В объявлении протокола можно написать : AnyObject."
    ),
    (
        question: "Какой тип можно использовать для хранения разных объектов, соответствующих одному протоколу?",
        answers: ["Любой класс", "Any", "Протокол как тип", "Void"],
        correctIndex: 2,
        hint: "Протоколы в Swift могут быть типами."
    ),
    (
        question: "Можно ли в протоколе объявлять инициализаторы?",
        answers: ["Нет", "Да", "Да, но только convenience", "Только required"],
        correctIndex: 1,
        hint: "Протокол может требовать определенные init."
    ),
    (
        question: "Что такое associatedtype в протоколах?",
        answers: ["Объявление вложенного класса", "Тип-плейсхолдер", "Способ наследования", "Ключевое слово для alias"],
        correctIndex: 1,
        hint: "Используется вместе с дженериками."
    )
] //11

// Вопросы UIKit 8
let navigationTabBarQuestions: questionForBase = [
    (
        question: "Какой класс в iOS используется для организации переходов между экранами по иерархии?",
        answers: ["UITabBarController", "UINavigationController", "UIPageViewController", "UIViewController"],
        correctIndex: 1,
        hint: "Этот контроллер управляет стеком экранов."
    ),
    (
        question: "Что отображается в верхней части экрана при использовании UINavigationController?",
        answers: ["TabBar", "ToolBar", "NavigationBar", "StatusBar"],
        correctIndex: 2,
        hint: "Здесь часто пишут заголовок экрана."
    ),
    (
        question: "Какой метод используется для перехода на новый экран через UINavigationController?",
        answers: ["present()", "pushViewController(_:animated:)", "show()", "open()"],
        correctIndex: 1,
        hint: "Добавляет контроллер в стек навигации."
    ),
    (
        question: "Как удалить текущий экран из стека UINavigationController?",
        answers: ["dismiss()", "popViewController(animated:)", "close()", "remove()"],
        correctIndex: 1,
        hint: "Метод начинается с pop."
    ),
    (
        question: "Какой контроллер используется для переключения между несколькими независимыми экранами с иконками снизу?",
        answers: ["UINavigationController", "UITabBarController", "UISplitViewController", "UICollectionViewController"],
        correctIndex: 1,
        hint: "Он располагается внизу и часто содержит иконки."
    ),
    (
        question: "Можно ли совместить UINavigationController и UITabBarController?",
        answers: ["Нет", "Да", "Только через storyboard", "Только программно"],
        correctIndex: 1,
        hint: "Вложенность контроллеров — обычная практика."
    ),
    (
        question: "Что задаёт свойство tabBarItem у UIViewController?",
        answers: ["Заголовок NavigationBar", "Иконку и текст в TabBar", "Цвет экрана", "Размер контроллера"],
        correctIndex: 1,
        hint: "Это отвечает за элемент в нижней панели."
    ),
    (
        question: "Как программно скрыть NavigationBar?",
        answers: ["navigationController?.navigationBar.isHidden = true", "tabBarController?.isHidden = true", "view.isHidden = true", "navigationController?.hide()"],
        correctIndex: 0,
        hint: "Используется свойство navigationBar.isHidden."
    ),
    (
        question: "Сколько экранов может содержать UITabBarController?",
        answers: ["Не более 5", "Не более 10", "Не ограничено", "Только 2"],
        correctIndex: 2,
        hint: "Технически ограничений нет, но рекомендуется до 5 вкладок."
    ),
    (
        question: "Как изменить порядок экранов в UITabBarController?",
        answers: ["Менять массив viewControllers", "Через push/pop", "Через NavigationBar", "Невозможно"],
        correctIndex: 0,
        hint: "TabBar управляется массивом контроллеров."
    )
] // 1
let autoLayoutQuestions: questionForBase = [
    (
        question: "Для чего используется Auto Layout в iOS?",
        answers: ["Для анимаций", "Для управления расположением и размером UI элементов", "Для работы с сетью", "Для хранения данных"],
        correctIndex: 1,
        hint: "Он отвечает за адаптацию интерфейса под разные экраны."
    ),
    (
        question: "Что такое NSLayoutConstraint?",
        answers: ["Элемент интерфейса", "Класс для задания ограничений Auto Layout", "Метод контроллера", "Свойство UIButton"],
        correctIndex: 1,
        hint: "Это объект, задающий отношение между элементами."
    ),
    (
        question: "Какой метод используется для активации массива ограничений?",
        answers: ["NSLayoutConstraint.start()", "NSLayoutConstraint.activate()", "NSLayoutConstraint.enable()", "NSLayoutConstraint.add()"],
        correctIndex: 1,
        hint: "Метод начинается с activate."
    ),
    (
        question: "Что нужно установить у вью перед добавлением констрейнтов программно?",
        answers: ["view.isHidden = false", "view.translatesAutoresizingMaskIntoConstraints = false", "view.isUserInteractionEnabled = true", "view.clipsToBounds = true"],
        correctIndex: 1,
        hint: "Нужно отключить автоматическую маску autoresizing."
    ),
    (
        question: "Что означает приоритет констрейнта?",
        answers: ["Какая вью будет на экране", "Насколько важно выполнение ограничения", "Порядок отображения слоёв", "Очередь событий"],
        correctIndex: 1,
        hint: "Чем выше значение, тем важнее ограничение."
    ),
    (
        question: "Какой диапазон значений может принимать приоритет NSLayoutConstraint?",
        answers: ["0–100", "0–1000", "0–10", "Только 1 или 0"],
        correctIndex: 1,
        hint: "1000 = обязательный приоритет."
    ),
    (
        question: "Какой инструмент Xcode помогает настраивать Auto Layout визуально?",
        answers: ["Instruments", "Interface Builder", "Playgrounds", "Profiler"],
        correctIndex: 1,
        hint: "Используется в storyboard/xib."
    ),
    (
        question: "Какое ограничение используется, чтобы задать фиксированную ширину элемента?",
        answers: ["widthAnchor.constraint(equalToConstant:)", "leadingAnchor.constraint()", "topAnchor.constraint()", "sizeToFit()"],
        correctIndex: 0,
        hint: "Привязывается через widthAnchor."
    ),
    (
        question: "Как привязать кнопку к центру экрана по горизонтали?",
        answers: ["button.centerXAnchor.constraint(equalTo: view.centerXAnchor)", "button.leadingAnchor.constraint(equalTo: view.leadingAnchor)", "button.trailingAnchor.constraint(equalTo: view.trailingAnchor)", "button.widthAnchor.constraint(equalToConstant:)"],
        correctIndex: 0,
        hint: "Используется centerXAnchor."
    ),
    (
        question: "Что произойдет, если два констрейнта противоречат друг другу?",
        answers: ["Приложение вылетит", "Xcode автоматически выберет один", "Auto Layout сломает один из констрейнтов", "Ничего"],
        correctIndex: 2,
        hint: "Система при конфликте понижает приоритет одного из ограничений."
    )
] //2
let tableCollectionQuestions: questionForBase = [
    (
        question: "Для чего используется UITableView?",
        answers: ["Для отображения сетки изображений", "Для отображения списка данных в одной колонке", "Для работы с сетью", "Для хранения данных"],
        correctIndex: 1,
        hint: "UITableView показывает строки, организованные в секции."
    ),
    (
        question: "Какой протокол нужно реализовать, чтобы предоставить данные в UITableView?",
        answers: ["UITableViewDelegate", "UITableViewDataSource", "UICollectionViewDelegate", "UICollectionViewFlowLayout"],
        correctIndex: 1,
        hint: "Этот протокол содержит методы numberOfRowsInSection и cellForRowAt."
    ),
    (
        question: "Какой метод отвечает за создание и настройку ячейки в UITableView?",
        answers: ["tableView(_:cellForRowAt:)", "tableView(_:numberOfRowsInSection:)", "tableView(_:didSelectRowAt:)", "tableView(_:heightForRowAt:)"],
        correctIndex: 0,
        hint: "Метод возвращает UITableViewCell."
    ),
    (
        question: "Для чего используется UICollectionView?",
        answers: ["Для сеточного отображения элементов", "Для отображения текста", "Для управления навигацией", "Для работы с автолейаутом"],
        correctIndex: 0,
        hint: "Обычно используется для сеток или кастомных раскладок."
    ),
    (
        question: "Какой объект управляет расположением элементов в UICollectionView?",
        answers: ["UICollectionViewCell", "UICollectionViewFlowLayout", "UICollectionViewDelegate", "UICollectionReusableView"],
        correctIndex: 1,
        hint: "По умолчанию это FlowLayout."
    ),
    (
        question: "Как зарегистрировать кастомную ячейку для TableView?",
        answers: ["tableView.register(_:forCellReuseIdentifier:)", "tableView.dequeueReusableCell()", "tableView.reloadData()", "tableView.addSubview()"],
        correctIndex: 0,
        hint: "Это нужно сделать перед использованием dequeueReusableCell."
    ),
    (
        question: "Какой метод вызывается при выборе строки в UITableView?",
        answers: ["tableView(_:cellForRowAt:)", "tableView(_:didSelectRowAt:)", "tableView(_:numberOfRowsInSection:)", "tableView(_:viewForHeaderInSection:)"],
        correctIndex: 1,
        hint: "Метод делегата, связанный с действием выбора."
    ),
    (
        question: "Что возвращает метод numberOfSections(in:) в UITableViewDataSource?",
        answers: ["Количество строк", "Количество секций", "Высоту секции", "Количество ячеек в секции"],
        correctIndex: 1,
        hint: "По умолчанию этот метод возвращает 1."
    ),
    (
        question: "Какой класс отвечает за переиспользование ячеек в TableView и CollectionView?",
        answers: ["UITableViewCell и UICollectionViewCell", "UIViewController", "UIResponder", "UITableViewDelegate"],
        correctIndex: 0,
        hint: "Ячейки наследуются от этих классов."
    ),
    (
        question: "Что произойдет, если не использовать механизм переиспользования ячеек?",
        answers: ["Таблица не загрузится", "Будет утечка памяти", "Сильно снизится производительность", "Ничего"],
        correctIndex: 2,
        hint: "Ячейки будут создаваться заново, что очень затратно."
    )
] //3
let uiControlQuestions: questionForBase = [
    (
        question: "Какое свойство определяет типы событий, на которые реагирует UIButton?",
        answers: ["actionType", "controlEvents", "targetAction", "eventMask"],
        correctIndex: 1,
        hint: "Используется перечисление UIControl.Event"
    ),
    (
        question: "Какой метод используется для связывания события UIControl с обработчиком?",
        answers: ["addTarget(_:action:for:)", "bindAction(_:event:)", "setHandler(_:event:)", "connect(_:to:)"],
        correctIndex: 0,
        hint: "Самый распространённый способ через addTarget"
    ),
    (
        question: "Какое событие генерируется при отпускании кнопки внутри её границ?",
        answers: ["touchDown", "touchUpInside", "touchDragInside", "valueChanged"],
        correctIndex: 1,
        hint: "Чаще всего используется для UIButton"
    ),
    (
        question: "Какое событие используется для слайдера UISlider при изменении значения?",
        answers: ["touchDragInside", "editingChanged", "valueChanged", "dragging"],
        correctIndex: 2,
        hint: "Срабатывает при изменении value"
    ),
    (
        question: "Что произойдет, если вызвать addTarget дважды с одинаковыми параметрами?",
        answers: ["Ошибка компиляции", "Будет вызван один раз", "Метод будет вызван дважды", "Событие не произойдет"],
        correctIndex: 2,
        hint: "addTarget не проверяет уникальность связей"
    ),
    (
        question: "Какое событие срабатывает, когда пользователь прикасается к элементу управления?",
        answers: ["touchDown", "touchUpInside", "editingDidBegin", "dragEnter"],
        correctIndex: 0,
        hint: "Первое касание всегда touchDown"
    ),
    (
        question: "Как удалить обработчик события у UIControl?",
        answers: ["removeAction(_:)", "removeTarget(_:action:for:)", "clearHandlers()", "disableEvent(for:)"],
        correctIndex: 1,
        hint: "Противоположность addTarget"
    ),
    (
        question: "Какое событие характерно для UITextField при изменении текста?",
        answers: ["editingChanged", "valueChanged", "textChanged", "inputUpdated"],
        correctIndex: 0,
        hint: "UIControl поддерживает editingChanged"
    ),
    (
        question: "Можно ли одному UIControl назначить несколько действий на разные события?",
        answers: ["Нет", "Да", "Только одно", "Зависит от типа элемента"],
        correctIndex: 1,
        hint: "Один control может слушать разные UIControl.Event"
    ),
    (
        question: "Что делает метод sendActions(for:)?",
        answers: ["Отправляет события всем слушателям", "Удаляет все события", "Прерывает событие", "Вызывает только последнее действие"],
        correctIndex: 0,
        hint: "Можно вручную инициировать событие"
    )
] // 4
let stackViewQuestions: questionForBase = [
    (
        question: "Какой класс используется для упрощённого управления автолейаутом путём размещения в ряд нескольких вью?",
        answers: ["UIStackView", "UICollectionView", "UITableView", "UIViewController"],
        correctIndex: 0,
        hint: "Это контейнер для упорядочивания подвидов по оси."
    ),
    (
        question: "Какие бывают оси у UIStackView?",
        answers: ["Vertical и Horizontal", "Left и Right", "Up и Down", "Center и Edge"],
        correctIndex: 0,
        hint: "Варианты направления расположения — только два."
    ),
    (
        question: "Какое свойство отвечает за интервал между элементами в UIStackView?",
        answers: ["spacing", "distribution", "alignment", "margin"],
        correctIndex: 0,
        hint: "Это свойство задаёт расстояние."
    ),
    (
        question: "Какое свойство отвечает за выравнивание элементов внутри UIStackView?",
        answers: ["alignment", "axis", "spacing", "distribution"],
        correctIndex: 0,
        hint: "Речь идёт о выравнивании, а не распределении."
    ),
    (
        question: "Какое свойство управляет распределением пространства между элементами?",
        answers: ["distribution", "alignment", "axis", "spacing"],
        correctIndex: 0,
        hint: "Отвечает именно за распределение."
    ),
    (
        question: "Можно ли вкладывать один UIStackView внутрь другого?",
        answers: ["Да", "Нет", "Только в вертикальном режиме", "Только в горизонтальном режиме"],
        correctIndex: 0,
        hint: "Это частый приём для сложных интерфейсов."
    ),
    (
        question: "Какое свойство включает или отключает использование layoutMargins у UIStackView?",
        answers: ["isLayoutMarginsRelativeArrangement", "usesSafeArea", "clipsToBounds", "contentMode"],
        correctIndex: 0,
        hint: "Название начинается с isLayoutMargins..."
    ),
    (
        question: "Что произойдёт, если скрыть один из arrangedSubviews у UIStackView?",
        answers: ["StackView пересчитает компоновку и уберёт элемент", "Элемент останется на месте", "Вылетит ошибка", "Ничего не изменится"],
        correctIndex: 0,
        hint: "UIStackView автоматически реагирует на скрытые элементы."
    ),
    (
        question: "Можно ли использовать UIStackView без Auto Layout?",
        answers: ["Нет, нужен Auto Layout", "Да, только через фреймы", "Да, но ограниченно", "Только в iPadOS"],
        correctIndex: 0,
        hint: "UIStackView изначально проектировался под Auto Layout."
    ),
    (
        question: "Как добавить в UIStackView новый элемент?",
        answers: ["addArrangedSubview()", "addSubview()", "insertSubview()", "appendView()"],
        correctIndex: 0,
        hint: "Метод специально создан для добавления именно в arrangedSubviews."
    )
] //5
let animationQuestions: questionForBase = [
    (
        question: "Какой класс используется для анимаций свойств во UIView?",
        answers: ["UIView", "CALayer", "CAAnimation", "UIViewPropertyAnimator"],
        correctIndex: 0,
        hint: "Самый часто используемый API."
    ),
    (
        question: "Какой метод применяется для выполнения анимации с изменением свойств UIView?",
        answers: ["UIView.animate()", "UIView.start()", "UIView.play()", "UIView.runAnimation()"],
        correctIndex: 0,
        hint: "Этот метод принимает блок с изменениями."
    ),
    (
        question: "Какое свойство у UIView обычно анимируется для перемещения по экрану?",
        answers: ["frame или center", "tag", "backgroundColor", "alpha"],
        correctIndex: 0,
        hint: "Координаты или прямоугольник вида."
    ),
    (
        question: "Какое свойство у UIView отвечает за прозрачность и может быть анимировано?",
        answers: ["alpha", "isHidden", "opacityMask", "tintColor"],
        correctIndex: 0,
        hint: "Число от 0 до 1."
    ),
    (
        question: "Какой класс Core Animation используется для базовой анимации слоя?",
        answers: ["CABasicAnimation", "CAKeyframeAnimation", "CASpringAnimation", "CAEmitterLayer"],
        correctIndex: 0,
        hint: "Самый простой вариант анимации слоя."
    ),
    (
        question: "Что делает свойство 'duration' у анимации?",
        answers: ["Задает длительность анимации", "Задает количество повторов", "Определяет задержку перед началом", "Определяет кривую ускорения"],
        correctIndex: 0,
        hint: "Измеряется в секундах."
    ),
    (
        question: "Какой параметр в UIView.animate задает стиль ускорения анимации?",
        answers: ["options", "duration", "delay", "curve"],
        correctIndex: 0,
        hint: "Можно выбрать easeIn, easeOut и т.п."
    ),
    (
        question: "Какой класс используется для создания анимаций с пружинным эффектом?",
        answers: ["CASpringAnimation", "CABasicAnimation", "UIViewAnimator", "CAKeyframeAnimation"],
        correctIndex: 0,
        hint: "Это анимация с 'упругим' возвратом."
    ),
    (
        question: "Можно ли объединить несколько анимаций в группу?",
        answers: ["Да, с помощью CAAnimationGroup", "Нет, каждая анимация выполняется отдельно", "Только для UIView.animate", "Только через SwiftUI"],
        correctIndex: 0,
        hint: "Это делается через специальный класс группы."
    ),
    (
        question: "Какое свойство у анимации определяет, повторяется ли она?",
        answers: ["repeatCount", "loop", "cycle", "autoreverse"],
        correctIndex: 0,
        hint: "Можно указать число или .infinity."
    )
] //6
let viewControllerQuestions: questionForBase = [
    (
        question: "Какой базовый класс контроллера экранов используется в UIKit?",
        answers: ["UIViewController", "UIWindow", "UIView", "UIResponder"],
        correctIndex: 0,
        hint: "Каждый экран наследуется от него."
    ),
    (
        question: "Какой метод вызывается при первом создании и загрузке View?",
        answers: ["viewDidAppear", "viewDidLoad", "viewWillAppear", "loadView"],
        correctIndex: 1,
        hint: "Он вызывается один раз после загрузки view."
    ),
    (
        question: "Какой метод вызывается перед тем, как View появится на экране?",
        answers: ["viewDidAppear", "viewWillAppear", "viewDidLoad", "viewWillDisappear"],
        correctIndex: 1,
        hint: "Вызывается каждый раз при показе."
    ),
    (
        question: "Какой метод вызывается, когда ViewController удаляется с экрана?",
        answers: ["viewDidDisappear", "viewWillDisappear", "deinit", "removeFromSuperview"],
        correctIndex: 0,
        hint: "Этот метод означает, что экран уже скрыт."
    ),
    (
        question: "Какой метод используется для загрузки кастомного layout из xib?",
        answers: ["init(coder:)", "loadView()", "awakeFromNib()", "viewDidLoad()"],
        correctIndex: 2,
        hint: "Вызывается у объектов, созданных из Interface Builder."
    ),
    (
        question: "Какой контроллер чаще всего применяется для организации иерархии экранов?",
        answers: ["UITabBarController", "UINavigationController", "UISplitViewController", "UIViewController"],
        correctIndex: 1,
        hint: "Он управляет стеком экранов."
    ),
    (
        question: "Какой метод используется для освобождения ресурсов при низкой памяти?",
        answers: ["deinit", "didReceiveMemoryWarning", "viewWillDisappear", "applicationDidEnterBackground"],
        correctIndex: 1,
        hint: "Метод помечен как устаревший, но встречается."
    ),
    (
        question: "Какой контроллер отвечает за табы внизу экрана?",
        answers: ["UITabBarController", "UINavigationController", "UISplitViewController", "UIPageViewController"],
        correctIndex: 0,
        hint: "Его используют для организации вкладок."
    ),
    (
        question: "Какой метод используется для добавления дочернего ViewController?",
        answers: ["addChild(_:)", "present(_:animated:)", "pushViewController(_:)", "insertSubview(:)"],
        correctIndex: 0,
        hint: "Метод явно указывает на добавление дочернего контроллера."
    ),
    (
        question: "Какой метод вызывается только один раз при создании view контроллера?",
        answers: ["viewDidLoad", "viewDidAppear", "viewWillAppear", "loadViewIfNeeded"],
        correctIndex: 0,
        hint: "Это самый первый метод, где настраивается UI."
    )
] //7
let viewsQuestions: questionForBase = [
    (
        question: "Какой класс является базовым для всех элементов интерфейса в UIKit?",
        answers: ["UIView", "UIControl", "CALayer", "UIResponder"],
        correctIndex: 0,
        hint: "Все кнопки, метки и поля ввода — это его наследники."
    ),
    (
        question: "Какое свойство UIView отвечает за прозрачность элемента?",
        answers: ["isHidden", "tintColor", "alpha", "backgroundColor"],
        correctIndex: 2,
        hint: "Значение от 0.0 до 1.0."
    ),
    (
        question: "Какое свойство UIView отвечает за скругление углов?",
        answers: ["clipsToBounds", "cornerRadius", "masksToBounds", "layer.cornerRadius"],
        correctIndex: 3,
        hint: "Это свойство задаётся через слой."
    ),
    (
        question: "Какое свойство нужно изменить, чтобы скрыть view?",
        answers: ["alpha", "opacity", "hidden", "isHidden"],
        correctIndex: 3,
        hint: "Булево свойство, отвечает только за отображение."
    ),
    (
        question: "Какое свойство UIView определяет его положение и размер?",
        answers: ["frame", "bounds", "center", "transform"],
        correctIndex: 0,
        hint: "Включает в себя x, y, width и height."
    ),
    (
        question: "Что делает метод addSubview(_:)?",
        answers: ["Удаляет view", "Добавляет дочернюю view", "Меняет родительскую view", "Перемещает view"],
        correctIndex: 1,
        hint: "Этот метод строит иерархию вью."
    ),
    (
        question: "Какое свойство отвечает за родительский элемент UIView?",
        answers: ["superview", "subviews", "window", "parent"],
        correctIndex: 0,
        hint: "Оно указывает на контейнер, в котором находится view."
    ),
    (
        question: "Какое свойство UIView хранит массив дочерних элементов?",
        answers: ["superview", "layer", "subviews", "children"],
        correctIndex: 2,
        hint: "Это массив всех вложенных views."
    ),
    (
        question: "Какой метод используется для анимации изменений UIView?",
        answers: ["UIView.animate(withDuration:animations:)", "setNeedsLayout()", "layoutIfNeeded()", "draw(_:)"],
        correctIndex: 0,
        hint: "Используется замыкание для описания анимации."
    ),
    (
        question: "Какое свойство UIView отвечает за фоновый цвет?",
        answers: ["tintColor", "backgroundColor", "layerColor", "alpha"],
        correctIndex: 1,
        hint: "Самое очевидное свойство для задания цвета."
    )
] //8

//Вопросы SwiftUI 7

let bindingsAndStateQuestions: questionForBase = [
    (
        question: "Какой property wrapper используется для хранения локального состояния внутри View?",
        answers: ["@ObservedObject", "@Binding", "@State", "@EnvironmentObject"],
        correctIndex: 2,
        hint: "@State хранит простые значения, связанные с жизненным циклом View."
    ),
    (
        question: "Какой property wrapper используется для передачи состояния между вью?",
        answers: ["@State", "@Binding", "@Environment", "@Published"],
        correctIndex: 1,
        hint: "Используется для двусторонней связи."
    ),
    (
        question: "Что произойдет при изменении значения свойства с @State?",
        answers: ["View обновится", "Значение сохранится в UserDefaults", "Произойдет перезапуск приложения", "Изменение не отразится на UI"],
        correctIndex: 0,
        hint: "@State автоматически вызывает перерисовку View."
    ),
    (
        question: "Можно ли напрямую передать @State в дочерний View?",
        answers: ["Да, напрямую", "Нет, нужно использовать @Binding", "Только через @EnvironmentObject", "Только через ObservableObject"],
        correctIndex: 1,
        hint: "Для передачи состояния нужно обернуть в $ и использовать @Binding."
    ),
    (
        question: "Как обозначается передача @State в качестве Binding?",
        answers: ["$variable", "&variable", "*variable", "@variable"],
        correctIndex: 0,
        hint: "Используется специальный префикс символа $."
    ),
    (
        question: "Что произойдет, если свойство с @State объявить как private?",
        answers: ["Ничего не изменится", "Будет ошибка компиляции", "View не обновится", "Свойство станет доступно только внутри этого View"],
        correctIndex: 3,
        hint: "private ограничивает область видимости свойства."
    ),
    (
        question: "Можно ли использовать @Binding без соответствующего @State?",
        answers: ["Да, всегда", "Нет, @Binding должен ссылаться на источник данных", "Да, если использовать @EnvironmentObject", "Да, но только с Published"],
        correctIndex: 1,
        hint: "@Binding требует источник состояния, обычно это @State."
    ),
    (
        question: "Какой property wrapper позволяет сохранять состояние даже при перезапуске приложения?",
        answers: ["@AppStorage", "@State", "@Binding", "@ObservedObject"],
        correctIndex: 0,
        hint: "Этот wrapper связан с UserDefaults."
    ),
    (
        question: "В чем отличие @State от @ObservedObject?",
        answers: ["@State работает только со структурами", "@ObservedObject работает с классами и ObservableObject", "@State нельзя использовать в ForEach", "@ObservedObject сохраняет данные в базе"],
        correctIndex: 1,
        hint: "@ObservedObject отслеживает изменения в классах, соответствующих ObservableObject."
    ),
    (
        question: "Какое ключевое слово используется для создания привязки вручную?",
        answers: ["Binding", "Link", "Connect", "StateBinding"],
        correctIndex: 0,
        hint: "Есть специальная структура для явной работы с привязками."
    )
] //1
let listsAndForEachQuestions: questionForBase = [
    (
        question: "Какой компонент используется для отображения прокручиваемого списка?",
        answers: ["List", "ScrollView", "ForEach", "Table"],
        correctIndex: 0,
        hint: "List — это базовый контейнер для списков в SwiftUI."
    ),
    (
        question: "Можно ли в List использовать ForEach для генерации элементов?",
        answers: ["Нет", "Да, это основной способ", "Только если элементы — строки", "Только при использовании NavigationView"],
        correctIndex: 1,
        hint: "ForEach позволяет динамически строить список элементов."
    ),
    (
        question: "Что необходимо, чтобы ForEach мог итерироваться по массиву кастомных объектов?",
        answers: ["Ничего", "Эти объекты должны быть Equatable", "Эти объекты должны соответствовать Identifiable", "Эти объекты должны наследоваться от NSObject"],
        correctIndex: 2,
        hint: "ForEach требует уникальные id для каждого элемента."
    ),
    (
        question: "Можно ли вложить ForEach внутрь List?",
        answers: ["Нет", "Да, это стандартный паттерн", "Только внутри Section", "Да, но только с Text"],
        correctIndex: 1,
        hint: "ForEach часто используется внутри List для рендеринга массивов."
    ),
    (
        question: "Как добавить разделы в List?",
        answers: ["Использовать Group", "Использовать VStack", "Использовать Section", "Использовать Divider"],
        correctIndex: 2,
        hint: "Section — специальный контейнер для секций в списке."
    ),
    (
        question: "Как сделать List, в котором элементы можно удалять свайпом?",
        answers: ["Добавить .onDelete к ForEach", "Использовать ScrollView", "Это невозможно", "Применить GestureRecognizer"],
        correctIndex: 0,
        hint: ".onDelete модификатор позволяет удалять элементы в списке."
    ),
    (
        question: "Как задать уникальный ключ для элементов ForEach?",
        answers: ["Через параметр id", "Через hashValue", "Через UUID()", "Через index"],
        correctIndex: 0,
        hint: "ForEach имеет инициализатор с id: \\.property."
    ),
    (
        question: "В чем отличие ScrollView от List?",
        answers: ["List поддерживает редактирование и swipe-действия", "List быстрее", "ScrollView нельзя использовать с Text", "Они ничем не отличаются"],
        correctIndex: 0,
        hint: "List — это специализированный контейнер для списков с интерактивностью."
    ),
    (
        question: "Как изменить стиль отображения списка?",
        answers: ["Использовать .listStyle()", "Использовать .background()", "Изменить через Theme", "Только через UIKit"],
        correctIndex: 0,
        hint: "У SwiftUI есть встроенные стили списков, например .grouped или .plain."
    ),
    (
        question: "Что произойдет, если в ForEach будут дубликаты id?",
        answers: ["Все элементы будут отображены", "Приложение выбросит ошибку", "Элементы с одинаковым id заменят друг друга", "ForEach автоматически пронумерует их"],
        correctIndex: 2,
        hint: "id должен быть уникальным, иначе данные будут путаться."
    )
] //2
let animationsQuestions: questionForBase = [
    (
        question: "Какой модификатор используется для добавления анимации к изменению состояния?",
        answers: [".animation()", ".withAnimation()", ".transition()", ".animate()"],
        correctIndex: 0,
        hint: "Это базовый модификатор анимации в SwiftUI."
    ),
    (
        question: "Как выполнить анимацию внутри блока кода?",
        answers: [".transition()", "withAnimation { ... }", ".animate()", ".easeIn()"],
        correctIndex: 1,
        hint: "withAnimation оборачивает изменения состояния, чтобы они анимировались."
    ),
    (
        question: "Какой протокол должны реализовать кастомные анимации?",
        answers: ["Animatable", "Equatable", "Identifiable", "Hashable"],
        correctIndex: 0,
        hint: "Animatable позволяет управлять промежуточными состояниями анимации."
    ),
    (
        question: "Что делает модификатор .transition()?",
        answers: ["Определяет стиль появления/исчезновения вида", "Добавляет задержку", "Изменяет скорость анимации", "Задает повторение"],
        correctIndex: 0,
        hint: ".transition управляет входом и выходом представления."
    ),
    (
        question: "Какой модификатор задаёт бесконечное повторение анимации?",
        answers: [".repeatForever()", ".infinite()", ".loop()", ".cycle()"],
        correctIndex: 0,
        hint: ".repeatForever позволяет циклично воспроизводить анимацию."
    ),
    (
        question: "Какой встроенный тип отвечает за плавность анимации?",
        answers: ["TimingCurve", "Animation", "EaseEffect", "Interpolator"],
        correctIndex: 1,
        hint: "Animation задаёт скорость, кривую и поведение анимации."
    ),
    (
        question: "Как задать задержку перед началом анимации?",
        answers: [".delay()", ".pause()", ".hold()", ".after()"],
        correctIndex: 0,
        hint: "У Animation есть метод delay(_:)."
    ),
    (
        question: "Как сделать анимацию, которая туда и обратно повторяется?",
        answers: [".reverse()", ".autoreverses(true)", ".mirror()", ".loopBack()"],
        correctIndex: 1,
        hint: "autoreverses = true заставляет анимацию возвращаться в исходное состояние."
    ),
    (
        question: "Что произойдет, если не указать модификатор анимации?",
        answers: ["Изменение произойдет мгновенно", "Будет использована стандартная ease-in", "SwiftUI выдаст ошибку", "Анимация не сработает только для Text"],
        correctIndex: 0,
        hint: "Без анимации состояние меняется моментально."
    ),
    (
        question: "Какой модификатор используется для плавного появления/исчезновения?",
        answers: [".opacity()", ".fade()", ".blur()", ".mask()"],
        correctIndex: 0,
        hint: "opacity — самый частый способ сделать fade-анимацию."
    )
] //3
let stackGridQuestions: questionForBase = [
    (
        question: "Какой контейнер располагает элементы горизонтально?",
        answers: ["HStack", "VStack", "ZStack", "LazyHGrid"],
        correctIndex: 0,
        hint: "Название говорит само за себя: Horizontal Stack."
    ),
    (
        question: "Какой контейнер накладывает элементы друг на друга?",
        answers: ["HStack", "VStack", "ZStack", "LazyVGrid"],
        correctIndex: 2,
        hint: "Z-ось — это глубина, значит элементы накладываются."
    ),
    (
        question: "Какой модификатор позволяет задать отступы между элементами в Stack?",
        answers: [".padding()", ".spacing()", ".margin()", ".frame()"],
        correctIndex: 1,
        hint: "Есть специальный параметр у HStack и VStack."
    ),
    (
        question: "Чем LazyHGrid отличается от HStack?",
        answers: [
            "Grid строит сетку по строкам и колонкам",
            "Grid всегда центрирует элементы",
            "Grid работает только внутри ScrollView",
            "Grid автоматически анимирует переходы"
        ],
        correctIndex: 0,
        hint: "Grid умеет работать с несколькими строками/колонками."
    ),
    (
        question: "Какой контейнер лучше использовать для вертикальной сетки?",
        answers: ["VStack", "LazyVGrid", "List", "ScrollView"],
        correctIndex: 1,
        hint: "LazyVGrid позволяет эффективно строить сетку по столбцам."
    ),
    (
        question: "Как можно указать количество колонок в LazyVGrid?",
        answers: [
            "Передав массив GridItem",
            "Задав spacing",
            "Используя frame",
            "Устанавливая alignment"
        ],
        correctIndex: 0,
        hint: "GridItem управляет колонками и их размером."
    ),
    (
        question: "Что произойдет, если в VStack слишком много элементов?",
        answers: [
            "Они выйдут за пределы экрана",
            "Они автоматически прокручиваются",
            "Они сжимаются до минимального размера",
            "SwiftUI выбросит ошибку"
        ],
        correctIndex: 0,
        hint: "Stack сам по себе не скроллится."
    ),
    (
        question: "Какой alignment используется по умолчанию в HStack?",
        answers: [".top", ".center", ".leading", ".baseline"],
        correctIndex: 1,
        hint: "Элементы выравниваются по центру по вертикали."
    ),
    (
        question: "Какой alignment используется по умолчанию в VStack?",
        answers: [".leading", ".center", ".trailing", ".firstTextBaseline"],
        correctIndex: 1,
        hint: "Элементы выравниваются по центру по горизонтали."
    ),
    (
        question: "Как сделать, чтобы LazyVGrid начал прокручиваться?",
        answers: [
            "Обёрнуть его в ScrollView",
            "Добавить .scrollable() модификатор",
            "Указать большое spacing",
            "Вызвать .animate()"
        ],
        correctIndex: 0,
        hint: "Grid сам по себе не скроллится, нужен ScrollView."
    )
] //4
let navigationSheetsQuestions: questionForBase = [
    (
        question: "Какой контейнер используется для навигации в SwiftUI?",
        answers: ["NavigationStack", "NavigationView", "NavigationController", "NavigationSplitView"],
        correctIndex: 0,
        hint: "В iOS 16 и новее основной контейнер — NavigationStack."
    ),
    (
        question: "Какой модификатор открывает новый экран при нажатии?",
        answers: [".sheet()", ".navigationDestination()", ".fullScreenCover()", ".popover()"],
        correctIndex: 1,
        hint: "Используется для перехода внутри NavigationStack."
    ),
    (
        question: "Какой способ позволяет открыть модальное окно во весь экран?",
        answers: [".sheet()", ".alert()", ".fullScreenCover()", ".popover()"],
        correctIndex: 2,
        hint: ".fullScreenCover() делает модальное представление на весь экран."
    ),
    (
        question: "Что нужно передать в .sheet() для его отображения?",
        answers: ["Bool или Binding", "NavigationPath", "GridItem", "Alignment"],
        correctIndex: 0,
        hint: "Обычно передают Binding<Bool> или item."
    ),
    (
        question: "Как закрыть экран, открытый через NavigationStack?",
        answers: ["Использовать dismiss()", "Вызвать .close()", "Просто свайпнуть", "Только через rootView"],
        correctIndex: 0,
        hint: "В SwiftUI есть специальный dismiss() из Environment."
    ),
    (
        question: "Какой контейнер заменяет NavigationView на iPadOS?",
        answers: ["NavigationStack", "NavigationSplitView", "NavigationController", "Sidebar"],
        correctIndex: 1,
        hint: "SplitView позволяет работать с несколькими панелями."
    ),
    (
        question: "Какой модификатор позволяет привязать переход к NavigationPath?",
        answers: [".navigationDestination()", ".sheet()", ".navigationLink()", ".fullScreenCover()"],
        correctIndex: 0,
        hint: "Работает с NavigationPath и данными."
    ),
    (
        question: "Какой элемент чаще всего используется для перехода на другой экран в NavigationStack?",
        answers: ["NavigationLink", "Button", "Label", "Text"],
        correctIndex: 0,
        hint: "NavigationLink — это основной триггер навигации."
    ),
    (
        question: "Какой модификатор удобен для отображения диалога выбора?",
        answers: [".sheet()", ".confirmationDialog()", ".popover()", ".alert()"],
        correctIndex: 1,
        hint: "confirmationDialog позволяет показывать список вариантов."
    ),
    (
        question: "Какой способ открыть небольшой всплывающий экран?",
        answers: [".popover()", ".sheet()", ".alert()", ".fullScreenCover()"],
        correctIndex: 0,
        hint: "popover показывает небольшое плавающее окно."
    )
] //5
let environmentObservableObjectQuestions: questionForBase = [
    (
        question: "Какой property wrapper используется для доступа к системным значениям окружения?",
        answers: ["@State", "@Binding", "@Environment", "@ObservedObject"],
        correctIndex: 2,
        hint: "@Environment позволяет получать значения окружения, например colorScheme."
    ),
    (
        question: "Какой wrapper создаёт и управляет объектом ObservableObject в корневом вью?",
        answers: ["@StateObject", "@ObservedObject", "@EnvironmentObject", "@Published"],
        correctIndex: 0,
        hint: "@StateObject инициализируется один раз и управляет жизненным циклом объекта."
    ),
    (
        question: "Что делает @Published в ObservableObject?",
        answers: ["Обновляет UI при изменении свойства", "Создаёт новый объект", "Сохраняет данные на диск", "Делает объект доступным в Environment"],
        correctIndex: 0,
        hint: "Изменение свойства вызывает обновление всех подписанных вью."
    ),
    (
        question: "Какой wrapper используется для передачи объекта ObservableObject сверху вниз во все дочерние вью?",
        answers: ["@ObservedObject", "@StateObject", "@EnvironmentObject", "@Binding"],
        correctIndex: 2,
        hint: "@EnvironmentObject делает объект доступным всему дереву вью."
    ),
    (
        question: "Как наблюдать объект, который передан в вью извне и не создаётся заново?",
        answers: ["@ObservedObject", "@StateObject", "@EnvironmentObject", "@Binding"],
        correctIndex: 0,
        hint: "@ObservedObject подходит для объектов, переданных извне."
    ),
    (
        question: "Что произойдёт, если @EnvironmentObject не будет передан в иерархию вью?",
        answers: ["Ничего", "Краш приложения во время выполнения", "UI не обновится", "Компилятор выдаст ошибку"],
        correctIndex: 1,
        hint: "Приложение упадёт в рантайме, если объект не передан."
    ),
    (
        question: "Как правильно наблюдать изменения ObservableObject внутри вью?",
        answers: ["@StateObject или @ObservedObject", "@Environment", "@Binding", "NotificationCenter"],
        correctIndex: 0,
        hint: "SwiftUI автоматически обновляет вью, если объект отмечен нужным property wrapper."
    ),
    (
        question: "Какой протокол должен реализовать класс, чтобы использовать @Published свойства?",
        answers: ["ObservableObject", "Codable", "Identifiable", "Equatable"],
        correctIndex: 0,
        hint: "Только ObservableObject поддерживает публикацию изменений."
    ),
    (
        question: "Что делает @ObservedObject при каждом ререндере вью?",
        answers: ["Пересоздаёт объект", "Управляет памятью объекта", "Не изменяет объект", "Сохраняет объект в Environment"],
        correctIndex: 2,
        hint: "@ObservedObject просто подписывается на изменения, объект остаётся прежним."
    ),
    (
        question: "Как получить доступ к EnvironmentObject внутри дочерней вью?",
        answers: ["@EnvironmentObject", "@ObservedObject", "@StateObject", "@Published"],
        correctIndex: 0,
        hint: "Используем @EnvironmentObject для получения объекта из окружения."
    )
] //6
let viewsModifiersQuestions: questionForBase = [
    (
        question: "Какой модификатор изменяет цвет текста в SwiftUI?",
        answers: ["foregroundColor", "background", "padding", "frame"],
        correctIndex: 0,
        hint: "Используется для изменения цвета текста в вью."
    ),
    (
        question: "Какой модификатор добавляет отступы вокруг вью?",
        answers: ["frame", "padding", "cornerRadius", "opacity"],
        correctIndex: 1,
        hint: "Padding создаёт внутренние отступы вью."
    ),
    (
        question: "Какой модификатор изменяет размер области вью?",
        answers: ["padding", "opacity", "frame", "background"],
        correctIndex: 2,
        hint: "Frame позволяет задать ширину и высоту вью."
    ),
    (
        question: "Как сделать закруглённые углы у вью?",
        answers: ["clipShape", "cornerRadius", "padding", "opacity"],
        correctIndex: 1,
        hint: "cornerRadius задаёт радиус скругления углов."
    ),
    (
        question: "Какой модификатор меняет прозрачность вью?",
        answers: ["shadow", "background", "opacity", "border"],
        correctIndex: 2,
        hint: "Opacity управляет видимостью вью."
    ),
    (
        question: "Какой модификатор добавляет тень к вью?",
        answers: ["cornerRadius", "clipShape", "shadow", "padding"],
        correctIndex: 2,
        hint: "Shadow добавляет тень под вью."
    ),
    (
        question: "Какой модификатор обрезает вью по форме?",
        answers: ["clipShape", "frame", "opacity", "foregroundColor"],
        correctIndex: 0,
        hint: "clipShape позволяет обрезать вью по заданной фигуре."
    ),
    (
        question: "Как задать фон для вью?",
        answers: ["background", "padding", "cornerRadius", "shadow"],
        correctIndex: 0,
        hint: "Background задаёт цвет или вью-фон для текущего вью."
    ),
    (
        question: "Как изменить шрифт текста в SwiftUI?",
        answers: ["foregroundColor", "font", "opacity", "padding"],
        correctIndex: 1,
        hint: "Font позволяет задать стиль и размер текста."
    ),
    (
        question: "Как применить несколько модификаторов к вью?",
        answers: ["Внутри ZStack", "В отдельном VStack", "Через запятую", "Цепочкой через точку"],
        correctIndex: 3,
        hint: "Модификаторы применяются последовательно через точку, например: .padding().background()"
    )
] //7

//Store Data 5

let keychainQuestions: questionForBase = [
    (
        question: "Для чего чаще всего используется Keychain в iOS?",
        answers: ["Хранение анимаций", "Хранение паролей и токенов", "Хранение изображений", "Кэширование таблиц"],
        correctIndex: 1,
        hint: "Keychain предназначен для хранения чувствительных данных, таких как пароли и токены."
    ),
    (
        question: "Какой фреймворк предоставляет API для работы с Keychain?",
        answers: ["UIKit", "Security", "Foundation", "CryptoKit"],
        correctIndex: 1,
        hint: "Работа с Keychain реализована в фреймворке Security."
    ),
    (
        question: "Какая функция используется для добавления данных в Keychain?",
        answers: ["SecItemAdd", "SecItemSave", "SecStoreAdd", "KeychainInsert"],
        correctIndex: 0,
        hint: "Для добавления используется SecItemAdd."
    ),
    (
        question: "Какой метод применяется для получения данных из Keychain?",
        answers: ["SecItemUpdate", "SecItemCopyMatching", "SecItemRetrieve", "SecItemGet"],
        correctIndex: 1,
        hint: "SecItemCopyMatching возвращает сохранённые данные."
    ),
    (
        question: "Какой метод используется для обновления записи в Keychain?",
        answers: ["SecItemUpdate", "SecItemEdit", "SecItemChange", "SecItemModify"],
        correctIndex: 0,
        hint: "Для изменения данных служит SecItemUpdate."
    ),
    (
        question: "Как удалить элемент из Keychain?",
        answers: ["SecItemRemove", "SecItemDelete", "SecItemErase", "KeychainClear"],
        correctIndex: 1,
        hint: "SecItemDelete удаляет элемент."
    ),
    (
        question: "Какие данные можно хранить в Keychain?",
        answers: ["Только изображения", "Только строки", "Пароли, токены, сертификаты", "Только числа"],
        correctIndex: 2,
        hint: "Keychain поддерживает хранение паролей, токенов и сертификатов."
    ),
    (
        question: "Keychain автоматически синхронизируется между устройствами через:",
        answers: ["iCloud Keychain", "App Store", "UserDefaults", "Core Data"],
        correctIndex: 0,
        hint: "При включённой опции используется iCloud Keychain."
    ),
    (
        question: "Что вернёт SecItemCopyMatching при ошибке?",
        answers: ["nil", "OSStatus код ошибки", "false", "Пустую строку"],
        correctIndex: 1,
        hint: "SecItemCopyMatching возвращает OSStatus код ошибки."
    ),
    (
        question: "Каким образом данные в Keychain защищены?",
        answers: ["Они шифруются системой", "Они обфусцируются кодом", "Они сохраняются в SQLite", "Они хранятся как JSON"],
        correctIndex: 0,
        hint: "iOS сама шифрует данные в Keychain на уровне системы."
    )
] //1
let fileManagerQuestions: questionForBase = [
    (
        question: "Какой класс используется в iOS для работы с файловой системой?",
        answers: ["FileController", "FileManager", "NSFileSystem", "StorageManager"],
        correctIndex: 1,
        hint: "Apple предоставляет FileManager для работы с файлами и папками."
    ),
    (
        question: "Метод FileManager для проверки существования файла:",
        answers: ["fileExists(atPath:)", "pathExists()", "checkFile()", "verifyFile(at:)"],
        correctIndex: 0,
        hint: "Метод fileExists(atPath:) возвращает true/false."
    ),
    (
        question: "Где можно хранить данные, которые должны сохраняться между запусками приложения?",
        answers: ["Caches", "Temporary", "Documents", "Bundle"],
        correctIndex: 2,
        hint: "Для постоянного хранения используется Documents."
    ),
    (
        question: "Как получить путь к временной директории?",
        answers: ["FileManager.default.temporaryDirectory", "FileManager.default.tempPath()", "NSTemporaryFolder()", "File.tempDirectory"],
        correctIndex: 0,
        hint: "temporaryDirectory возвращает URL временной папки."
    ),
    (
        question: "Метод для создания папки:",
        answers: ["createDirectory(at:withIntermediateDirectories:attributes:)", "makeFolder()", "newDirectory()", "createFolder(at:)"],
        correctIndex: 0,
        hint: "Используется createDirectory(at:withIntermediateDirectories:attributes:)."
    ),
    (
        question: "Где лучше хранить кэшируемые данные?",
        answers: ["Documents", "Caches", "Bundle", "Library/CoreData"],
        correctIndex: 1,
        hint: "Caches предназначена для временных данных, которые система может удалить."
    ),
    (
        question: "Какой метод FileManager используется для удаления файла?",
        answers: ["delete(at:)", "removeItem(at:)", "eraseFile()", "clearFile(at:)"],
        correctIndex: 1,
        hint: "removeItem(at:) удаляет файл или папку."
    ),
    (
        question: "Как получить содержимое папки?",
        answers: ["contentsOfDirectory(atPath:)", "getFiles()", "listFolder()", "fetchDirectory()"],
        correctIndex: 0,
        hint: "contentsOfDirectory(atPath:) возвращает массив имён файлов."
    ),
    (
        question: "Можно ли изменять файлы внутри Bundle?",
        answers: ["Да, можно", "Только для чтения", "Да, но с ограничениями", "Можно при наличии прав администратора"],
        correctIndex: 1,
        hint: "Bundle read-only, файлы там менять нельзя."
    ),
    (
        question: "Какой тип возвращает метод urls(for:in:) при запросе директорий?",
        answers: ["String", "URL", "Path", "FileHandle"],
        correctIndex: 1,
        hint: "urls(for:in:) возвращает массив URL."
    )
] //2
let coreDataQuestions: questionForBase = [
    (
        question: "Какой класс служит удобным контейнером для настройки Core Data (создаёт model, coordinator и context)?",
        answers: [
            "NSPersistentContainer",
            "NSManagedObject",
            "NSFetchRequest",
            "NSPersistentStore"
        ],
        correctIndex: 0,
        hint: "NSPersistentContainer инкапсулирует стек Core Data и упрощает инициализацию."
    ),
    (
        question: "Какой метод необходимо вызвать, чтобы сохранить изменения в контексте?",
        answers: [
            "context.rollback()",
            "try context.save()",
            "context.fetch()",
            "context.reset()"
        ],
        correctIndex: 1,
        hint: "Для записи изменений в хранилище вызывают save()."
    ),
    (
        question: "Что такое NSManagedObject?",
        answers: [
            "Класс для управления persistent store",
            "Тип, представляющий одну запись (сущность) в Core Data",
            "Объект для выполнения сетевых запросов",
            "Специальный fetch controller"
        ],
        correctIndex: 2,
        hint: "NSManagedObject — это модельный объект Core Data (экземпляр сущности)."
    ),
    (
        question: "Что такое NSFetchRequest?",
        answers: [
            "Класс для сохранения данных",
            "Механизм миграции схемы",
            "Тип для представления тестовых данных",
            "Запрос для выборки объектов из контекста"
        ],
        correctIndex: 3,
        hint: "NSFetchRequest задаёт критерии выборки (entity, predicate, sortDescriptors)."
    ),
    (
        question: "Что такое «faulting» в Core Data?",
        answers: [
            "Механизм отложенной загрузки данных для экономии памяти",
            "Ошибка при сохранении",
            "Обновление схемы в рантайме",
            "Автоматическое удаление объектов"
        ],
        correctIndex: 0,
        hint: "Fault — это заглушка; реальные данные подгружаются по мере обращения."
    ),
    (
        question: "Как применить фильтр при выборке объектов?",
        answers: [
            "Указать sortDescriptors",
            "Установить NSPredicate в fetch request",
            "Вызвать context.filter()",
            "Использовать NSBatchDeleteRequest"
        ],
        correctIndex: 1,
        hint: "NSPredicate задаёт условие для NSFetchRequest."
    ),
    (
        question: "Какие варианты конкуренции контекста есть и зачем они нужны?",
        answers: [
            "main и background — для управления потоками (UI vs background)",
            "strong и weak — для управления ссылками",
            "readonly и readwrite — для доступа к данным",
            "local и remote — для сетевой синхронизации"
        ],
        correctIndex: 2,
        hint: "Подумай про потоки: main (UI) и private (background)."
    ),
    (
        question: "Для чего используется NSFetchedResultsController?",
        answers: [
            "Для массового удаления объектов",
            "Для автоматической миграции схем",
            "Для отслеживания и обновления таблицы при изменениях Core Data",
            "Для сохранения контекста в файл"
        ],
        correctIndex: 3,
        hint: "NSFetchedResultsController удобно использовать с UITableView/UICollectionView."
    ),
    (
        question: "Как корректно удалить объект из Core Data?",
        answers: [
            "context.remove(object)",
            "context.delete(object) и затем try context.save()",
            "object = nil",
            "use NSBatchDeleteRequest только"
        ],
        correctIndex: 0,
        hint: "Удаляем через context.delete(_:) и сохраняем контекст."
    ),
    (
        question: "Что такое lightweight migration в Core Data?",
        answers: [
            "Удаление устаревших сущностей автоматически",
            "Автоматическая миграция изменений модели, не требующая ручных миграционных шагов",
            "Способ ускорить fetch запросы",
            "Инструмент для бэкапа данных"
        ],
        correctIndex: 1,
        hint: "Lightweight migration работает при простых изменениях схемы (добавление атрибута и т.п.)."
    )
] //3
let userDefaultsQuestions: questionForBase = [
    (
        question: "Для чего используется UserDefaults?",
        answers: [
            "Для хранения небольших настроек и предпочтений пользователя",
            "Для хранения больших файлов",
            "Для сетевых запросов",
            "Для создания базы данных"
        ],
        correctIndex: 0,
        hint: "UserDefaults подходит для небольших данных: настройки, флаги, токены."
    ),
    (
        question: "Как получить доступ к стандартному экземпляру UserDefaults?",
        answers: [
            "UserDefaults.default",
            "UserDefaults.standard",
            "UserDefaults.shared",
            "UserDefaults.main"
        ],
        correctIndex: 1,
        hint: "Чаще всего используют UserDefaults.standard."
    ),
    (
        question: "Какой тип данных нельзя хранить напрямую в UserDefaults?",
        answers: [
            "String",
            "Int",
            "Custom Struct без кодирования",
            "Bool"
        ],
        correctIndex: 2,
        hint: "UserDefaults работает только с Property List совместимыми типами."
    ),
    (
        question: "Как удалить значение по ключу из UserDefaults?",
        answers: [
            "defaults.remove(forKey:)",
            "defaults.clear(key:)",
            "defaults.delete(key:)",
            "defaults.reset()"
        ],
        correctIndex: 3,
        hint: "Метод называется removeObject(forKey:)."
    ),
    (
        question: "Что возвращает метод bool(forKey:) если ключа нет?",
        answers: [
            "false",
            "true",
            "nil",
            "0"
        ],
        correctIndex: 0,
        hint: "Для Bool и Int возвращаются значения по умолчанию, а не nil."
    ),
    (
        question: "Как сохранить массив строк в UserDefaults?",
        answers: [
            "defaults.setStringArray(_:forKey:)",
            "defaults.set(_:forKey:)",
            "defaults.addArray(_:key:)",
            "defaults.saveStrings(_:)"
        ],
        correctIndex: 1,
        hint: "set(_:forKey:) работает и с массивами стандартных типов."
    ),
    (
        question: "Можно ли синхронизировать UserDefaults с iCloud?",
        answers: [
            "Нет, никогда",
            "Да, через NSUbiquitousKeyValueStore",
            "Да, через CoreData",
            "Да, через URLSession"
        ],
        correctIndex: 2,
        hint: "Синхронизация в iCloud делается через отдельный API, а не напрямую."
    ),
    (
        question: "Как сбросить все сохраненные UserDefaults?",
        answers: [
            "defaults.resetAll()",
            "Удалить все ключи через removeObject(forKey:)",
            "defaults.clearAll()",
            "defaults.dropDatabase()"
        ],
        correctIndex: 1,
        hint: "Прямого метода нет, нужно вручную удалить все ключи."
    ),
    (
        question: "Можно ли хранить Date в UserDefaults?",
        answers: [
            "Да, напрямую",
            "Нет, только в String",
            "Нет, только через Int",
            "Только через JSON"
        ],
        correctIndex: 0,
        hint: "Date входит в Property List совместимые типы."
    ),
    (
        question: "Нужно ли явно вызывать метод synchronize() в современных приложениях?",
        answers: [
            "Да, всегда обязательно",
            "Да, только на iOS 10",
            "Нет, система сама сохраняет изменения",
            "Да, при каждом изменении"
        ],
        correctIndex: 2,
        hint: "Сейчас synchronize() устарел — система сама пишет данные на диск."
    )
] //4
let propertyListQuestions: questionForBase = [
    (
        question: "Что такое Property List (plist) в iOS?",
        answers: [
            "Файл для хранения структурированных данных в XML или бинарном формате",
            "База данных SQLite",
            "Файл с ресурсами приложения",
            "Локальный веб-сервер"
        ],
        correctIndex: 0,
        hint: "Plist хранит данные в виде XML или в бинарной форме — например настройки и конфигурацию."
    ),
    (
        question: "Какое расширение обычно имеют plist-файлы?",
        answers: [
            ".xml",
            ".plist",
            ".json",
            ".data"
        ],
        correctIndex: 1,
        hint: "Обычное расширение — .plist."
    ),
    (
        question: "Какой тип данных нельзя записать в plist без предварительного кодирования?",
        answers: [
            "String",
            "Int",
            "Пользовательская структура без Codable",
            "Bool"
        ],
        correctIndex: 2,
        hint: "Для кастомных типов обычно требуется Codable и PlistEncoder/Decoder."
    ),
    (
        question: "Какой API удобен для кодирования/декодирования Swift моделей в/из plist?",
        answers: [
            "JSONDecoder / JSONEncoder",
            "PropertyListSerialization (низкоуровневый)",
            "FileManager",
            "PropertyListEncoder / PropertyListDecoder"
        ],
        correctIndex: 3,
        hint: "PropertyListEncoder/PropertyListDecoder — аналог JSONEncoder/Decoder для plist."
    ),
    (
        question: "Как получить URL ресурса plist, лежащего в бандле приложения?",
        answers: [
            "Bundle.main.url(forResource: \"Name\", ofType: \"plist\")",
            "FileManager.default.urls(for: .documentDirectory, ...)",
            "UserDefaults.standard.url(forKey:)",
            "NSTemporaryDirectory()"
        ],
        correctIndex: 0,
        hint: "Для файлов в бандле используется Bundle.main."
    ),
    (
        question: "Что делает NSDictionary(contentsOf: url)?",
        answers: [
            "Создаёт NSDictionary из содержимого plist по URL",
            "Сохраняет словарь в файл",
            "Удаляет plist",
            "Конвертирует plist в JSON"
        ],
        correctIndex: 0,
        hint: "NSDictionary умеет инициализироваться из plist-файла."
    ),
    (
        question: "Можно ли хранить бинарные данные (например, картинку в Data) в plist?",
        answers: [
            "Нет, только текст",
            "Только base64 строкой",
            "Да, непосредственно через Data",
            "Только через JSON"
        ],
        correctIndex: 2,
        hint: "Plist поддерживает тип Data для бинарных данных."
    ),
    (
        question: "Какой формат plist удобнее для чтения человеком при отладке?",
        answers: [
            "Бинарный формат",
            "YAML",
            "JSON",
            "Текстовый XML (human-readable)"
        ],
        correctIndex: 3,
        hint: "XML-вариант plist легче читать вручную, бинарный более компактный."
    ),
    (
        question: "Можно ли изменять plist, который находится в бандле приложения во время выполнения?",
        answers: [
            "Да, можно изменять plist в Documents",
            "Нет, файлы бандла только для чтения — их нужно копировать в Documents",
            "Да, если приложение подписано",
            "Да, через UserDefaults"
        ],
        correctIndex: 1,
        hint: "Bundle — read-only; для изменения копию обычно кладут в Documents."
    ),
    (
        question: "Какой подход лучше для хранения сложных типизированных настроек приложения?",
        answers: [
            "Просто плоские ключи в UserDefaults",
            "Codable-модели, сериализованные в plist или JSON",
            "Хранить всё в текстовом файле",
            "Хранить настройки в изображениях"
        ],
        correctIndex: 1,
        hint: "Codable + Plist/JSON даёт структуру и типобезопасность."
    )
] //5

//Networking 7

let webSocketQuestions: questionForBase = [
    (
        question: "Что такое WebSocket?",
        answers: [
            "Протокол для двустороннего взаимодействия клиента и сервера в реальном времени",
            "Формат сериализации данных",
            "Расширение для HTTP-заголовков",
            "Фреймворк для работы с JSON"
        ],
        correctIndex: 0,
        hint: "WebSocket — это протокол поверх TCP для постоянного соединения."
    ),
    (
        question: "На каком уровне OSI работает WebSocket?",
        answers: [
            "Канальном",
            "Прикладном",
            "Сетевом",
            "Физическом"
        ],
        correctIndex: 1,
        hint: "WebSocket — это прикладной протокол, как и HTTP."
    ),
    (
        question: "Как начинается соединение WebSocket?",
        answers: [
            "Прямой TCP-коннект без заголовков",
            "Через HTTP-запрос с апгрейдом соединения",
            "Через DNS-запрос",
            "Через FTP"
        ],
        correctIndex: 1,
        hint: "WebSocket стартует как HTTP и апгрейдится в постоянное соединение."
    ),
    (
        question: "Какой метод HTTP используется для инициализации WebSocket?",
        answers: [
            "POST",
            "GET",
            "PUT",
            "OPTIONS"
        ],
        correctIndex: 1,
        hint: "Для апгрейда в WebSocket используется GET-запрос."
    ),
    (
        question: "Какой заголовок обязателен при установке WebSocket соединения?",
        answers: [
            "Authorization",
            "Upgrade: websocket",
            "Content-Type",
            "Accept-Encoding"
        ],
        correctIndex: 1,
        hint: "Заголовок Upgrade: websocket переводит соединение в режим WebSocket."
    ),
    (
        question: "Как WebSocket поддерживает постоянное соединение?",
        answers: [
            "Периодические heartbeat/ping сообщения",
            "Через многократные HTTP-запросы",
            "Через UDP-браузерный канал",
            "Через FTP keep-alive"
        ],
        correctIndex: 0,
        hint: "Для поддержания соединения используются ping/pong пакеты."
    ),
    (
        question: "Какой порт обычно используется для WebSocket без TLS?",
        answers: [
            "21",
            "80",
            "443",
            "22"
        ],
        correctIndex: 1,
        hint: "WebSocket по умолчанию работает через порт 80 (ws://)."
    ),
    (
        question: "Какой порт обычно используется для защищённого WebSocket (wss://)?",
        answers: [
            "22",
            "143",
            "443",
            "110"
        ],
        correctIndex: 2,
        hint: "WSS — это WebSocket поверх TLS, как HTTPS, обычно на порту 443."
    ),
    (
        question: "Как в iOS реализовать поддержку WebSocket?",
        answers: [
            "Использовать URLSessionWebSocketTask",
            "Только через сторонние библиотеки",
            "Только через TCP-сокеты вручную",
            "Только через Combine"
        ],
        correctIndex: 0,
        hint: "Apple предлагает URLSessionWebSocketTask начиная с iOS 13."
    ),
    (
        question: "Какое преимущество WebSocket перед HTTP-поллингом?",
        answers: [
            "Меньшее потребление ресурсов и задержек",
            "Использует меньше памяти на устройстве",
            "Работает только через UDP",
            "Заменяет JSON"
        ],
        correctIndex: 0,
        hint: "Главное преимущество — постоянное соединение и меньше задержек."
    )
] //1
let urlSessionQuestions: questionForBase = [
    (
        question: "Что такое URLSession в iOS?",
        answers: [
            "Класс для работы с базами данных",
            "API для управления сетевыми запросами",
            "Фреймворк для анимаций",
            "Менеджер фоновых задач для CoreData"
        ],
        correctIndex: 1,
        hint: "Используется для загрузки данных по сети"
    ),
    (
        question: "Какой метод используют для создания стандартной сессии?",
        answers: [
            "URLSession.shared",
            "URLSession.default()",
            "URLSession.configuration()",
            "URLSession.makeShared()"
        ],
        correctIndex: 0,
        hint: "Это синглтон для простых запросов"
    ),
    (
        question: "Что возвращает метод dataTask(with:completionHandler:)?",
        answers: [
            "Data",
            "URLResponse",
            "URLSessionDataTask",
            "URLSessionConfiguration"
        ],
        correctIndex: 2,
        hint: "Это объект, который нужно запустить методом resume()"
    ),
    (
        question: "Как запустить выполнение задачи URLSessionDataTask?",
        answers: [
            "start()",
            "run()",
            "resume()",
            "execute()"
        ],
        correctIndex: 2,
        hint: "Метод начинается с буквы 'r'"
    ),
    (
        question: "Для чего используется URLSessionConfiguration?",
        answers: [
            "Для хранения ответа сервера",
            "Для настройки параметров сессии",
            "Для кэширования изображений",
            "Для управления JSON-парсингом"
        ],
        correctIndex: 1,
        hint: "Можно настроить таймауты, кэш и политику cookies"
    ),
    (
        question: "Какой тип задачи предназначен для загрузки файла на сервер?",
        answers: [
            "dataTask",
            "uploadTask",
            "downloadTask",
            "streamTask"
        ],
        correctIndex: 1,
        hint: "Название метода начинается с upload"
    ),
    (
        question: "Какой тип задачи используется для скачивания файла на диск?",
        answers: [
            "dataTask",
            "uploadTask",
            "downloadTask",
            "streamTask"
        ],
        correctIndex: 2,
        hint: "Она сохраняет временный файл на диск"
    ),
    (
        question: "Какой delegate используется для отслеживания прогресса загрузки?",
        answers: [
            "URLSessionDataDelegate",
            "URLSessionDownloadDelegate",
            "URLSessionTaskDelegate",
            "URLSessionStreamDelegate"
        ],
        correctIndex: 1,
        hint: "Нужен именно для скачивания"
    ),
    (
        question: "Что произойдёт, если не вызвать resume() у задачи?",
        answers: [
            "Задача выполнится автоматически",
            "Задача не начнётся",
            "Произойдёт ошибка компиляции",
            "Запрос отправится, но без ответа"
        ],
        correctIndex: 1,
        hint: "По умолчанию задачи создаются в приостановленном состоянии"
    ),
    (
        question: "Как завершить все задачи в URLSession?",
        answers: [
            "session.stop()",
            "session.invalidateAndCancel()",
            "session.close()",
            "session.finish()"
        ],
        correctIndex: 1,
        hint: "Метод одновременно отменяет и завершает сессию"
    )
] //2
let codableQuestions: questionForBase = [
    (
        question: "Что делает протокол Codable?",
        answers: [
            "Обеспечивает работу с Core Data",
            "Обеспечивает доступ к файловой системе",
            "Позволяет кодировать и декодировать данные",
            "Отвечает за работу с сетью"
        ],
        correctIndex: 2,
        hint: "Это комбинация Encodable и Decodable"
    ),
    (
        question: "Что делает протокол Decodable?",
        answers: [
            "Позволяет преобразовать объект в JSON",
            "Позволяет преобразовать JSON в объект",
            "Позволяет кодировать в бинарный формат",
            "Работает только с XML"
        ],
        correctIndex: 1,
        hint: "Используется для парсинга JSON → объект"
    ),
    (
        question: "Какой класс используют для преобразования JSON в объект?",
        answers: [
            "JSONEncoder",
            "JSONSerialization",
            "JSONManager",
            "JSONDecoder"
        ],
        correctIndex: 3,
        hint: "Он является зеркалом для JSONEncoder"
    ),
    (
        question: "Какой метод JSONDecoder используется для декодирования?",
        answers: [
            "parse(_:from:)",
            "read(_:)",
            "load(_:)",
            "decode(_:from:)"
        ],
        correctIndex: 3,
        hint: "Название совпадает с протоколом Decodable"
    ),
    (
        question: "Что вернёт JSONDecoder при ошибке парсинга?",
        answers: [
            "nil",
            "Ошибка (throw)",
            "Пустой объект",
            "Строку с ошибкой"
        ],
        correctIndex: 1,
        hint: "Метод decode бросает ошибку"
    ),
    (
        question: "Как можно изменить названия ключей при декодировании?",
        answers: [
            "Использовать CodingKeys",
            "Использовать KeyMapping",
            "Использовать JSONOptions",
            "Использовать CustomDecoder"
        ],
        correctIndex: 0,
        hint: "Обычно создают вложенный enum"
    ),
    (
        question: "Можно ли декодировать вложенные структуры?",
        answers: [
            "Нет, только плоские JSON",
            "Да, через вложенные CodingKeys",
            "Да, но только массивы",
            "Только с помощью сторонних библиотек"
        ],
        correctIndex: 1,
        hint: "Enum CodingKeys можно вложить"
    ),
    (
        question: "Какой протокол нужно реализовать, чтобы объект можно было закодировать в JSON?",
        answers: [
            "Decodable",
            "Codable",
            "Serializable",
            "Encodable"
        ],
        correctIndex: 3,
        hint: "Противоположность Decodable"
    ),
    (
        question: "Можно ли объединить Encodable и Decodable?",
        answers: [
            "Да, это Codable",
            "Нет, они несовместимы",
            "Да, но только вручную",
            "Только через JSONSerialization"
        ],
        correctIndex: 0,
        hint: "Codable = Encodable + Decodable"
    ),
    (
        question: "Что делает CodingKey?",
        answers: [
            "Определяет, какие ключи используются при кодировании/декодировании",
            "Задаёт правила сортировки JSON",
            "Фильтрует данные при декодировании",
            "Преобразует JSON в словарь"
        ],
        correctIndex: 0,
        hint: "Это enum с именами ключей"
    )
] //3
let jsonParsingQuestions: questionForBase = [
    (
        question: "Какой класс в Swift используется для преобразования JSON в объекты?",
        answers: [
            "JSONEncoder",
            "JSONSerialization",
            "DataFormatter",
            "JSONDecoder"
        ],
        correctIndex: 3,
        hint: "Этот класс работает вместе с Codable"
    ),
    (
        question: "Какой метод JSONSerialization преобразует JSON в Foundation объекты?",
        answers: [
            "data(withJSONObject:options:)",
            "jsonObject(with:options:)",
            "decode(_:from:)",
            "parse(_:)"
        ],
        correctIndex: 1,
        hint: "Метод возвращает Any (словарь или массив)"
    ),
    (
        question: "В каком формате должны быть данные для парсинга JSON?",
        answers: [
            "String",
            "Dictionary",
            "Data",
            "Array"
        ],
        correctIndex: 2,
        hint: "Обычно приходят из сети через URLSession"
    ),
    (
        question: "Какой протокол необходим для автоматического парсинга JSON в структуры?",
        answers: [
            "Codable",
            "Serializable",
            "Parsable",
            "EncodableOnly"
        ],
        correctIndex: 0,
        hint: "Это комбинация Encodable и Decodable"
    ),
    (
        question: "Какой метод JSONDecoder используется для парсинга?",
        answers: [
            "decode(_:from:)",
            "serialize(_:)",
            "parse(_:)",
            "load(_:)"
        ],
        correctIndex: 0,
        hint: "Название совпадает с протоколом Decodable"
    ),
    (
        question: "Что вернёт JSONSerialization.jsonObject(with:options:) при ошибке?",
        answers: [
            "nil",
            "throw",
            "empty dictionary",
            "empty array"
        ],
        correctIndex: 1,
        hint: "Метод генерирует ошибку, которую нужно ловить через try/catch"
    ),
    (
        question: "Что нужно сделать, чтобы ключи JSON совпали с именами свойств структуры?",
        answers: [
            "Использовать KeyPaths",
            "Сделать их одинаковыми",
            "Использовать CodingKeys",
            "Использовать JSONManager"
        ],
        correctIndex: 2,
        hint: "Часто создаётся вложенный enum"
    ),
    (
        question: "Что делает параметр .mutableContainers в JSONSerialization?",
        answers: [
            "Создаёт изменяемые контейнеры (NSMutableArray, NSMutableDictionary)",
            "Делает JSON кэшируемым",
            "Автоматически мапит JSON в структуры",
            "Фильтрует ключи JSON"
        ],
        correctIndex: 0,
        hint: "Этот параметр связан с типами Foundation"
    ),
    (
        question: "Какой тип чаще всего возвращает jsonObject(with:options:)?",
        answers: [
            "[String: Any]",
            "[Any]",
            "Data",
            "String"
        ],
        correctIndex: 0,
        hint: "JSON чаще всего представляет объект с ключами"
    ),
    (
        question: "Что произойдёт, если JSON невалидный?",
        answers: [
            "Он будет автоматически исправлен",
            "Вернётся пустой объект",
            "Будет выброшена ошибка",
            "Загрузится как строка"
        ],
        correctIndex: 2,
        hint: "Ошибку нужно обработать через do/try/catch"
    )
] //4
let restAPIQuestions: questionForBase = [
    (
        question: "Что такое REST API?",
        answers: [
            "Протокол передачи данных",
            "Архитектурный стиль для взаимодействия клиент-сервер",
            "Библиотека для работы с сетью в iOS",
            "Формат хранения данных"
        ],
        correctIndex: 1,
        hint: "Это не протокол, а архитектурный подход"
    ),
    (
        question: "Какой формат данных чаще всего используется в REST API?",
        answers: [
            "XML",
            "YAML",
            "Binary",
            "JSON"
        ],
        correctIndex: 3,
        hint: "Это текстовый формат, лёгкий для работы"
    ),
    (
        question: "Какой HTTP метод используется для получения данных?",
        answers: [
            "POST",
            "PUT",
            "DELETE",
            "GET"
        ],
        correctIndex: 3,
        hint: "Самый часто используемый метод"
    ),
    (
        question: "Какой HTTP метод используется для создания ресурса?",
        answers: [
            "POST",
            "GET",
            "PATCH",
            "DELETE"
        ],
        correctIndex: 0,
        hint: "Обычно отправляет данные на сервер"
    ),
    (
        question: "Какой HTTP метод используют для обновления ресурса?",
        answers: [
            "PUT",
            "GET",
            "POST",
            "HEAD"
        ],
        correctIndex: 0,
        hint: "Обычно заменяет объект целиком"
    ),
    (
        question: "Какой метод применяется для частичного обновления ресурса?",
        answers: [
            "POST",
            "PATCH",
            "PUT",
            "OPTIONS"
        ],
        correctIndex: 1,
        hint: "Его часто путают с PUT"
    ),
    (
        question: "Что означает код ответа 200?",
        answers: [
            "Успешное выполнение запроса",
            "Ошибка клиента",
            "Ошибка сервера",
            "Ресурс создан"
        ],
        correctIndex: 0,
        hint: "Самый часто встречающийся успешный ответ"
    ),
    (
        question: "Что означает код ответа 404?",
        answers: [
            "Сервер недоступен",
            "Ресурс не найден",
            "Ошибка аутентификации",
            "Запрос успешен"
        ],
        correctIndex: 1,
        hint: "Означает, что ресурс отсутствует"
    ),
    (
        question: "Какой заголовок HTTP используется для передачи формата данных?",
        answers: [
            "Authorization",
            "Accept",
            "Content-Type",
            "Cache-Control"
        ],
        correctIndex: 2,
        hint: "В нём обычно указывают application/json"
    ),
    (
        question: "Что означает принцип stateless в REST?",
        answers: [
            "Сервер хранит сессии клиентов",
            "Каждый запрос независим и не хранит состояния",
            "Сервер кэширует все запросы",
            "Клиент должен всегда быть онлайн"
        ],
        correctIndex: 1,
        hint: "Это одно из ключевых правил REST"
    )
] // 5
let errorRetryHandlingQuestions: questionForBase = [
    (
        question: "Какой ключевое слово используется для обработки ошибок в Swift?",
        answers: [
            "catch",
            "try",
            "throw",
            "do"
        ],
        correctIndex: 3,
        hint: "Обычно конструкция начинается именно с него"
    ),
    (
        question: "Как обозначить функцию, которая может выбрасывать ошибку?",
        answers: [
            "func test() error { }",
            "func test() throws { }",
            "func test() try { }",
            "func test() catch { }"
        ],
        correctIndex: 1,
        hint: "В сигнатуре используется специальное слово"
    ),
    (
        question: "Что делает ключевое слово throw?",
        answers: [
            "Запускает повторный запрос",
            "Отменяет выполнение функции",
            "Выбрасывает ошибку",
            "Сохраняет ошибку в лог"
        ],
        correctIndex: 2,
        hint: "С его помощью мы сигнализируем об ошибке"
    ),
    (
        question: "Что делает ключевое слово try?",
        answers: [
            "Превращает ошибку в строку",
            "Проверяет, может ли функция выбросить ошибку",
            "Выбрасывает ошибку",
            "Означает вызов функции с возможной ошибкой"
        ],
        correctIndex: 3,
        hint: "Обычно идёт перед вызовом метода"
    ),
    (
        question: "Чем отличается try? от try!",
        answers: [
            "try? возвращает опционал, try! – форс-unwrap",
            "try? вызывает повторный запрос, try! – нет",
            "try? работает только с асинхронным кодом",
            "try! доступно только в классах"
        ],
        correctIndex: 0,
        hint: "Первое безопасное, второе может вызвать крэш"
    ),
    (
        question: "Что такое Error в Swift?",
        answers: [
            "Класс для работы с сетевыми ошибками",
            "Базовый протокол для ошибок",
            "Enum с кодами ошибок",
            "Функция для логирования"
        ],
        correctIndex: 1,
        hint: "Любая ошибка должна ему соответствовать"
    ),
    (
        question: "Что обычно используют для повторных запросов (Retry)?",
        answers: [
            "URLCache",
            "DispatchQueue.asyncAfter",
            "NSLog",
            "UserDefaults"
        ],
        correctIndex: 1,
        hint: "Можно запускать повтор с задержкой"
    ),
    (
        question: "Как лучше всего ограничить количество повторных попыток?",
        answers: [
            "Использовать флаг success",
            "Хранить счётчик попыток",
            "Проверять URL",
            "Использовать DispatchGroup"
        ],
        correctIndex: 1,
        hint: "Счётчик нужен, чтобы не уйти в бесконечный цикл"
    ),
    (
        question: "Что означает стратегия exponential backoff?",
        answers: [
            "Каждый раз уменьшать задержку",
            "Каждый раз увеличивать задержку в 2 раза",
            "Повторять запросы без задержки",
            "Отправлять все запросы параллельно"
        ],
        correctIndex: 1,
        hint: "Например: 1с → 2с → 4с → 8с"
    ),
    (
        question: "Где лучше всего реализовать Retry-логику в iOS приложении?",
        answers: [
            "В Network Layer",
            "В UI-контроллере",
            "В AppDelegate",
            "В Storyboard"
        ],
        correctIndex: 0,
        hint: "Повтор должен быть централизован и не зависеть от UI"
    )
] // 6
let backgroundTasksQuestions: questionForBase = [
    (
        question: "Что такое Background Fetch в iOS?",
        answers: [
            "Механизм обновления интерфейса",
            "Функция периодической подгрузки данных в фоне",
            "Метод для ускорения UI",
            "Сервис для работы с файловой системой"
        ],
        correctIndex: 1,
        hint: "Позволяет приложению загружать данные, даже когда оно не активно"
    ),
    (
        question: "Какой метод AppDelegate вызывается при Background Fetch?",
        answers: [
            "application(_:didFinishLaunchingWithOptions:)",
            "applicationDidEnterBackground(_:)",
            "application(_:performFetchWithCompletionHandler:)",
            "applicationWillTerminate(_:)"
        ],
        correctIndex: 2,
        hint: "У него есть completionHandler"
    ),
    (
        question: "Что необходимо вызвать в completionHandler при завершении Background Fetch?",
        answers: [
            "UIUpdate.success",
            "UIApplication.shared.endBackgroundTask",
            "UIBackgroundModes.finish",
            "UIBackgroundFetchResult"
        ],
        correctIndex: 3,
        hint: "Передаётся результат: .newData, .noData или .failed"
    ),
    (
        question: "Как включить Background Fetch в приложении?",
        answers: [
            "В Info.plist указать UIBackgroundModes = fetch",
            "В настройках симулятора",
            "В UserDefaults",
            "Через JSONDecoder"
        ],
        correctIndex: 0,
        hint: "Для этого нужно добавить ключ в Info.plist"
    ),
    (
        question: "Что такое BGTaskScheduler?",
        answers: [
            "Класс для запуска фоновых задач в iOS 13+",
            "Таймер для UI",
            "Инструмент для CoreData",
            "Объект для работы с Codable"
        ],
        correctIndex: 0,
        hint: "Это современный API для Background Tasks"
    ),
    (
        question: "Как зарегистрировать задачу через BGTaskScheduler?",
        answers: [
            "BGTaskScheduler.shared.register(forTaskWithIdentifier:using:launchHandler:)",
            "UIApplication.shared.registerBackgroundTask(_:)",
            "URLSession.shared.background(_:)",
            "DispatchQueue.global().asyncAfter(_:)"
        ],
        correctIndex: 0,
        hint: "Метод у BGTaskScheduler.shared"
    ),
    (
        question: "Какой тип задачи используется для периодической фоновой работы?",
        answers: [
            "BGProcessingTask",
            "BGFetchTask",
            "BGAppRefreshTask",
            "BGDownloadTask"
        ],
        correctIndex: 2,
        hint: "Это аналог Background Fetch, но в BGTaskScheduler API"
    ),
    (
        question: "Какой тип задачи используется для долгих операций (например, синхронизация)?",
        answers: [
            "BGProcessingTask",
            "BGFetchTask",
            "BGAppRefreshTask",
            "BGDownloadTask"
        ],
        correctIndex: 0,
        hint: "Она может выполняться даже при закрытом приложении"
    ),
    (
        question: "Что обязательно нужно вызвать внутри обработчика BGTask?",
        answers: [
            "task.setCompleted(success:)",
            "task.end()",
            "UIApplication.shared.endBackgroundTask",
            "task.invalidate()"
        ],
        correctIndex: 0,
        hint: "Без этого система будет считать задачу незавершённой"
    ),
    (
        question: "Можно ли гарантировать точное время запуска Background Fetch?",
        answers: [
            "Да, всегда",
            "Нет, система сама решает",
            "Да, но только на Wi-Fi",
            "Да, но только при зарядке"
        ],
        correctIndex: 1,
        hint: "Это управляется iOS для экономии батареи"
    )
] // 7

//Concurrency 7

let actorsQuestions: questionForBase = [
    (
        question: "Что такое actor в Swift?",
        answers: [
            "Класс для работы с сетью",
            "Структура для хранения данных",
            "Референс-тип для безопасного доступа из разных потоков",
            "Фреймворк для анимаций"
        ],
        correctIndex: 2,
        hint: "Основная цель — защита данных от гонок потоков"
    ),
    (
        question: "Чем actor отличается от класса?",
        answers: [
            "Actor — value type, а класс — reference type",
            "Actor автоматически синхронизирует доступ к своим данным",
            "Actor нельзя наследовать",
            "Actor используется только в UIKit"
        ],
        correctIndex: 1,
        hint: "У класса нет защиты от data races"
    ),
    (
        question: "Как объявить actor в Swift?",
        answers: [
            "struct MyActor { }",
            "actor MyActor { }",
            "class MyActor: Actor { }",
            "enum MyActor { }"
        ],
        correctIndex: 1,
        hint: "Ключевое слово совпадает с названием концепта"
    ),
    (
        question: "Можно ли наследовать actor от другого actor?",
        answers: [
            "Да, как и классы",
            "Нет, наследование не поддерживается",
            "Да, но только если final",
            "Только при условии Codable"
        ],
        correctIndex: 1,
        hint: "Акторы спроектированы без иерархий наследования"
    ),
    (
        question: "Как получить доступ к свойству actor из другой асинхронной функции?",
        answers: [
            "let value = actor.property",
            "await actor.property",
            "actor.property.sync()",
            "try actor.get()"
        ],
        correctIndex: 1,
        hint: "Нужен специальный модификатор"
    ),
    (
        question: "Можно ли вызывать методы actor без await?",
        answers: [
            "Да, всегда",
            "Нет, никогда",
            "Только синхронные методы внутри самого actor",
            "Только приватные методы"
        ],
        correctIndex: 2,
        hint: "Внутри самого actor блокировки не нужны"
    ),
    (
        question: "Что такое reentrancy у actor?",
        answers: [
            "Актор может исполнять несколько задач одновременно",
            "Актор может приостанавливать задачу и обрабатывать другие",
            "Актор не поддерживает асинхронные вызовы",
            "Актор всегда выполняет задачи последовательно без приостановки"
        ],
        correctIndex: 1,
        hint: "Это связано с тем, что await освобождает актор"
    ),
    (
        question: "Что произойдёт, если несколько задач попытаются изменить состояние actor одновременно?",
        answers: [
            "Будет краш",
            "Будет гонка данных",
            "Задачи выполнятся последовательно",
            "Состояние станет непредсказуемым"
        ],
        correctIndex: 2,
        hint: "Актор гарантирует сериализацию доступа"
    ),
    (
        question: "Какой атрибут позволяет обращаться к actor без await?",
        answers: [
            "@escaping",
            "@MainActor",
            "@unchecked Sendable",
            "@nonisolated"
        ],
        correctIndex: 3,
        hint: "Используется для методов, которые не зависят от состояния актора"
    ),
    (
        question: "Что такое @MainActor?",
        answers: [
            "Actor, выполняющийся на главном потоке",
            "Actor для фоновых потоков",
            "Actor для обработки ошибок",
            "Actor для синхронизации Codable"
        ],
        correctIndex: 0,
        hint: "Используется для UI-кода"
    )
] //1
let operationQueueQuestions: questionForBase = [
    (
        question: "Что такое OperationQueue в Swift?",
        answers: [
            "Очередь на основе потоков для выполнения операций",
            "Структура данных для хранения массивов",
            "Класс для сетевых запросов",
            "Очередь для анимаций Core Animation"
        ],
        correctIndex: 0,
        hint: "Используется для управления асинхронными задачами"
    ),
    (
        question: "Что представляет собой Operation в контексте OperationQueue?",
        answers: [
            "Асинхронная задача",
            "Обертка над потоками UI",
            "Функция main()",
            "Только сетевой запрос"
        ],
        correctIndex: 0,
        hint: "Это абстракция задачи, которую можно отменять и комбинировать"
    ),
    (
        question: "Как добавить задачу в OperationQueue?",
        answers: [
            "queue.addTask { }",
            "queue.addOperation { }",
            "queue.async { }",
            "queue.runOperation()"
        ],
        correctIndex: 1,
        hint: "Метод называется почти так же, как сам объект"
    ),
    (
        question: "Как по умолчанию выполняются операции в OperationQueue?",
        answers: [
            "Только последовательно",
            "Только параллельно",
            "Параллельно, но можно ограничить",
            "Только на главном потоке"
        ],
        correctIndex: 2,
        hint: "Есть свойство maxConcurrentOperationCount"
    ),
    (
        question: "Как ограничить количество одновременно выполняемых операций?",
        answers: [
            "queue.limit = Int",
            "queue.maxConcurrentOperationCount = Int",
            "queue.concurrentCount = Int",
            "queue.threadLimit = Int"
        ],
        correctIndex: 1,
        hint: "Свойство начинается с max"
    ),
    (
        question: "Можно ли приостановить выполнение OperationQueue?",
        answers: [
            "Да, с помощью свойства isSuspended",
            "Нет, только удалить очередь",
            "Да, только через GCD",
            "Нет, операции всегда продолжаются"
        ],
        correctIndex: 0,
        hint: "Есть булевое свойство, которое можно переключать"
    ),
    (
        question: "Как задать зависимость одной операции от другой?",
        answers: [
            "op1.depend(on: op2)",
            "op1.addDependency(op2)",
            "queue.addDependency(op1, op2)",
            "OperationQueue.setDependency()"
        ],
        correctIndex: 1,
        hint: "Зависимость указывается на уровне самой операции"
    ),
    (
        question: "Что произойдет, если операция с зависимостью отменена?",
        answers: [
            "Зависимая операция выполнится",
            "Зависимая операция тоже отменится",
            "Зависимая операция зависнет",
            "Ничего не изменится"
        ],
        correctIndex: 1,
        hint: "Зависимости учитываются при отмене"
    ),
    (
        question: "Как гарантировать выполнение операции на главном потоке?",
        answers: [
            "Использовать DispatchQueue.main",
            "Установить queue.qualityOfService = .userInteractive",
            "Использовать OperationQueue.main",
            "Вызвать op.runOnMain()"
        ],
        correctIndex: 2,
        hint: "Есть готовая очередь для этого"
    ),
    (
        question: "Что делает свойство qualityOfService у OperationQueue?",
        answers: [
            "Задает приоритет выполнения операций",
            "Определяет количество потоков",
            "Устанавливает главный поток",
            "Меняет режим памяти"
        ],
        correctIndex: 0,
        hint: "Служит для приоритезации задач"
    )
] // 2
let deadlocksRaceConditionsQuestions: questionForBase = [
    (
        question: "Что такое deadlock (взаимная блокировка)?",
        answers: [
            "Ситуация, когда поток бесконечно выполняется",
            "Ситуация, когда два потока ждут друг друга и никогда не продолжают работу",
            "Ошибка при декодировании данных",
            "Конфликт при работе с памятью"
        ],
        correctIndex: 1,
        hint: "Обычно возникает при неправильной работе с блокировками"
    ),
    (
        question: "Что такое race condition (гонка данных)?",
        answers: [
            "Ситуация, когда результат зависит от порядка выполнения потоков",
            "Ситуация, когда данные обрабатываются быстрее",
            "Специальный тип deadlock",
            "Ошибка при работе с сетью"
        ],
        correctIndex: 0,
        hint: "Непредсказуемый результат из-за доступа из разных потоков"
    ),
    (
        question: "Как часто воспроизводятся race conditions?",
        answers: [
            "Всегда при многопоточности",
            "Случайно, в зависимости от планировщика и времени",
            "Только в iOS",
            "Только в отладочном режиме"
        ],
        correctIndex: 1,
        hint: "Поэтому такие баги часто трудно отловить"
    ),
    (
        question: "Что может вызвать deadlock в GCD?",
        answers: [
            "Асинхронный вызов внутри background очереди",
            "Синхронный вызов на ту же очередь, где выполняется код",
            "Добавление операций без зависимостей",
            "Слишком много потоков"
        ],
        correctIndex: 1,
        hint: "Ситуация называется reentrant deadlock"
    ),
    (
        question: "Как избежать race conditions?",
        answers: [
            "Использовать больше потоков",
            "Применять блокировки, сериализацию или Actors",
            "Не использовать многопоточность",
            "Добавлять задержки между потоками"
        ],
        correctIndex: 1,
        hint: "Суть в синхронизации доступа к данным"
    ),
    (
        question: "Что произойдет, если два потока одновременно изменяют одно и то же свойство без синхронизации?",
        answers: [
            "Программа всегда упадет",
            "Значение будет обновлено корректно",
            "Возникнет race condition",
            "Потоки автоматически синхронизируются"
        ],
        correctIndex: 2,
        hint: "Именно это и есть гонка данных"
    ),
    (
        question: "Как может помочь serial DispatchQueue?",
        answers: [
            "Обеспечивает параллельное выполнение",
            "Гарантирует, что задачи выполняются последовательно",
            "Создает deadlock по умолчанию",
            "Ускоряет все задачи"
        ],
        correctIndex: 1,
        hint: "Выполнение строго по очереди предотвращает гонки"
    ),
    (
        question: "Какой инструмент в Swift Concurrency помогает избежать race conditions?",
        answers: [
            "DispatchSemaphore",
            "Actors",
            "NSLock",
            "OperationQueue"
        ],
        correctIndex: 1,
        hint: "Это новый тип, который изолирует доступ к состоянию"
    ),
    (
        question: "Что такое livelock?",
        answers: [
            "Ситуация, когда потоки работают, но не делают прогресса",
            "Полная остановка потоков",
            "Сбой памяти",
            "Аналог race condition"
        ],
        correctIndex: 0,
        hint: "Отличается от deadlock тем, что работа есть, но результата нет"
    ),
    (
        question: "Какая стратегия помогает минимизировать вероятность deadlock?",
        answers: [
            "Избегать вложенных блокировок",
            "Использовать только глобальные очереди",
            "Добавлять sleep() внутри потоков",
            "Не использовать многопоточность"
        ],
        correctIndex: 0,
        hint: "Главное правило: порядок захвата блокировок должен быть согласован"
    )
] //3
let synchronizationQuestions: questionForBase = [
    (
        question: "Что такое синхронизация в многопоточности?",
        answers: [
            "Процесс ускорения вычислений",
            "Ситуация взаимной блокировки",
            "Механизм для согласованного доступа к общим данным",
            "Асинхронная загрузка данных"
        ],
        correctIndex: 2,
        hint: "Это средство защиты от race conditions"
    ),
    (
        question: "Какой инструмент в Swift можно использовать для синхронизации потоков?",
        answers: [
            "NSLock",
            "DispatchSemaphore",
            "pthread_mutex",
            "Все перечисленные варианты"
        ],
        correctIndex: 3,
        hint: "В Swift есть несколько механизмов, выбирай под задачу"
    ),
    (
        question: "Что делает NSLock?",
        answers: [
            "Обеспечивает взаимное исключение при доступе к ресурсу",
            "Ускоряет выполнение задач",
            "Автоматически синхронизирует UI",
            "Создает race condition"
        ],
        correctIndex: 0,
        hint: "Простейший вариант блокировки"
    ),
    (
        question: "Что делает DispatchSemaphore со значением 1?",
        answers: [
            "Создает race condition",
            "Работает как мьютекс",
            "Отключает многопоточность",
            "Гарантирует deadlock"
        ],
        correctIndex: 1,
        hint: "Семафор со значением 1 — классический бинарный мьютекс"
    ),
    (
        question: "Как избежать проблемы при использовании нескольких блокировок?",
        answers: [
            "Захватывать блокировки в определенном порядке",
            "Использовать только глобальные очереди",
            "Не использовать блокировки вовсе",
            "Вызывать sleep() перед захватом"
        ],
        correctIndex: 0,
        hint: "Главное правило: всегда одинаковый порядок"
    ),
    (
        question: "Что такое reentrant lock?",
        answers: [
            "Блокировка, которая допускает повторный захват тем же потоком",
            "Блокировка, создающая deadlock",
            "Семафор с нулевым значением",
            "Тип race condition"
        ],
        correctIndex: 0,
        hint: "В Swift это NSRecursiveLock"
    ),
    (
        question: "Какая очередь GCD гарантирует синхронизацию при доступе к ресурсу?",
        answers: [
            "Concurrent Queue",
            "Main Queue",
            "Serial Queue",
            "Async Queue"
        ],
        correctIndex: 2,
        hint: "Задачи выполняются строго по одной"
    ),
    (
        question: "Что произойдет при слишком долгом удержании блокировки?",
        answers: [
            "Ускорится выполнение",
            "Может возникнуть задержка и блокировка других потоков",
            "Произойдет race condition",
            "Запустится автоматическая оптимизация"
        ],
        correctIndex: 1,
        hint: "Долгое удержание блокировки приводит к деградации"
    ),
    (
        question: "Какой механизм Swift Concurrency упрощает синхронизацию?",
        answers: [
            "DispatchGroup",
            "OperationQueue",
            "Actors",
            "NotificationCenter"
        ],
        correctIndex: 2,
        hint: "Они изолируют состояние и не требуют ручных блокировок"
    ),
    (
        question: "Что делает barrier в concurrent queue?",
        answers: [
            "Разрешает доступ всем задачам",
            "Приостанавливает очередь навсегда",
            "Блокирует UI поток",
            "Гарантирует эксклюзивное выполнение задачи"
        ],
        correctIndex: 3,
        hint: "Все задачи до барьера выполняются, затем барьер — и только потом остальные"
    )
] //4
let gcdQuestions: questionForBase = [
    (
        question: "Что такое GCD (Grand Central Dispatch)?",
        answers: [
            "Фреймворк для работы с многопоточностью",
            "Библиотека для работы с сетью",
            "Система логирования в iOS",
            "Механизм управления памятью"
        ],
        correctIndex: 0,
        hint: "GCD отвечает за асинхронное выполнение задач"
    ),
    (
        question: "Что представляет собой DispatchQueue?",
        answers: [
            "Очередь для выполнения задач",
            "База данных для хранения запросов",
            "Массив функций",
            "API для работы с анимациями"
        ],
        correctIndex: 0,
        hint: "Основная абстракция GCD"
    ),
    (
        question: "Какие бывают типы DispatchQueue?",
        answers: [
            "Serial и Concurrent",
            "Main и Global",
            "Async и Sync",
            "User и System"
        ],
        correctIndex: 0,
        hint: "Задачи могут выполняться последовательно или параллельно"
    ),
    (
        question: "Какая очередь используется для обновления UI?",
        answers: [
            "DispatchQueue.global()",
            "DispatchQueue(label:)",
            "DispatchQueue.main",
            "DispatchQueue.concurrent"
        ],
        correctIndex: 2,
        hint: "Все изменения интерфейса выполняются на главном потоке"
    ),
    (
        question: "Что делает метод async у DispatchQueue?",
        answers: [
            "Выполняет задачу асинхронно и немедленно блокирует поток",
            "Выполняет задачу асинхронно, не блокируя поток",
            "Выполняет задачу синхронно и ждет завершения",
            "Удаляет задачу из очереди"
        ],
        correctIndex: 1,
        hint: "Используется для выполнения без блокировки"
    ),
    (
        question: "Что делает метод sync у DispatchQueue?",
        answers: [
            "Выполняет задачу асинхронно",
            "Выполняет задачу синхронно, блокируя поток до завершения",
            "Добавляет задачу в очередь с приоритетом",
            "Отменяет все задачи"
        ],
        correctIndex: 1,
        hint: "Sync ждет завершения задачи"
    ),
    (
        question: "Что может вызвать deadlock в GCD?",
        answers: [
            "Вызов async внутри concurrent queue",
            "Вызов sync на той же очереди, где выполняется код",
            "Слишком много задач в global queue",
            "Использование DispatchGroup"
        ],
        correctIndex: 1,
        hint: "Называется reentrant deadlock"
    ),
    (
        question: "Что делает DispatchWorkItem?",
        answers: [
            "Обертка над задачей, которую можно отменять",
            "Очередь для параллельных задач",
            "Мьютекс для синхронизации",
            "API для работы с сетью"
        ],
        correctIndex: 0,
        hint: "Позволяет больше контролировать выполнение задач"
    ),
    (
        question: "Как задать приоритет выполнения задачи в GCD?",
        answers: [
            "Использовать разные global queues с QoS",
            "Присвоить Int приоритет",
            "Вызывать setPriority()",
            "Установить taskLevel"
        ],
        correctIndex: 0,
        hint: "Используются разные Quality of Service уровни"
    ),
    (
        question: "Что делает barrier в concurrent queue?",
        answers: [
            "Останавливает выполнение очереди",
            "Гарантирует эксклюзивное выполнение задачи",
            "Запускает все задачи одновременно",
            "Удаляет очередь"
        ],
        correctIndex: 1,
        hint: "Барьер гарантирует, что задача выполнится одна"
    )
] //5
let asyncAwaitQuestions: questionForBase = [
    (
        question: "Что такое async/await в Swift?",
        answers: [
            "Синтаксис для написания асинхронного кода в линейном стиле",
            "Новый тип данных для работы с JSON",
            "API для работы с сетью",
            "Метод синхронизации потоков"
        ],
        correctIndex: 0,
        hint: "Это способ работы с асинхронностью"
    ),
    (
        question: "Что возвращает функция, объявленная с async?",
        answers: [
            "Ничего не возвращает",
            "Обычное значение",
            "Future или значение в будущем",
            "DispatchQueue"
        ],
        correctIndex: 2,
        hint: "Результат доступен позже, а не сразу"
    ),
    (
        question: "Как вызывается функция, помеченная async?",
        answers: [
            "Через try",
            "Через asyncCall()",
            "Через await",
            "Через dispatch"
        ],
        correctIndex: 2,
        hint: "Ключевое слово await обязательно"
    ),
    (
        question: "Можно ли использовать await вне асинхронного контекста?",
        answers: [
            "Да, всегда",
            "Нет, только внутри async функций или Task",
            "Только в DispatchQueue",
            "Только в OperationQueue"
        ],
        correctIndex: 1,
        hint: "await должен быть внутри async"
    ),
    (
        question: "Что произойдет, если вызвать async функцию без await?",
        answers: [
            "Она выполнится синхронно",
            "Она выполнится, но результат будет проигнорирован",
            "Программа упадет",
            "Она автоматически добавится в глобальную очередь"
        ],
        correctIndex: 1,
        hint: "Код выполнится, но результат потеряешь"
    ),
    (
        question: "Что такое Task в Swift Concurrency?",
        answers: [
            "Контейнер для выполнения асинхронного кода",
            "Новый вид DispatchQueue",
            "Семафор для синхронизации",
            "Средство работы с UI"
        ],
        correctIndex: 0,
        hint: "Это единица выполнения"
    ),
    (
        question: "Как отменить выполнение Task?",
        answers: [
            "task.stop()",
            "task.cancel()",
            "task.invalidate()",
            "task.terminate()"
        ],
        correctIndex: 1,
        hint: "Есть специальный метод cancel()"
    ),
    (
        question: "Что произойдет, если внутри async функции вызвать sleep() вместо Task.sleep()?",
        answers: [
            "Будет правильная приостановка задачи",
            "Задача завершится с ошибкой",
            "Поток заблокируется",
            "Код выполнится быстрее"
        ],
        correctIndex: 2,
        hint: "Это синхронная блокировка"
    ),
    (
        question: "Что возвращает Task.detached?",
        answers: [
            "Задачу, привязанную к текущему контексту",
            "Глобальную очередь GCD",
            "Асинхронную задачу без наследования контекста",
            "NSOperation"
        ],
        correctIndex: 2,
        hint: "Detached — задача выполняется независимо"
    ),
    (
        question: "Можно ли комбинировать async/await с традиционными completion handlers?",
        answers: [
            "Нет, это несовместимо",
            "Да, но нужно использовать continuation",
            "Да, напрямую",
            "Только в Objective-C"
        ],
        correctIndex: 1,
        hint: "Используется withCheckedContinuation"
    )
] //6
let timerRunLoopQuestions: questionForBase = [
    (
        question: "Что делает класс Timer в iOS?",
        answers: [
            "Выполняет задачу сразу после вызова",
            "Запускает задачу по расписанию через определенный интервал",
            "Асинхронно загружает данные",
            "Управляет очередями GCD"
        ],
        correctIndex: 1,
        hint: "Используется для периодических или отложенных задач"
    ),
    (
        question: "Что такое RunLoop?",
        answers: [
            "Цикл, обрабатывающий события и ввод-вывод",
            "Интерфейс для работы с JSON",
            "Средство работы с потоками",
            "Механизм работы с сетью"
        ],
        correctIndex: 0,
        hint: "Основной цикл обработки событий"
    ),
    (
        question: "Как создать таймер, который повторяется каждые 5 секунд?",
        answers: [
            "Timer.scheduledTimer(withTimeInterval: 5, repeats: true, block: { })",
            "Timer.runLoopTimer(5)",
            "DispatchQueue.timer(5)",
            "RunLoop.every(5)"
        ],
        correctIndex: 0,
        hint: "Есть специальный метод scheduledTimer"
    ),
    (
        question: "На каком RunLoop обычно работают UI-таймеры?",
        answers: [
            "На background RunLoop",
            "На custom RunLoop",
            "На главном RunLoop",
            "На любом DispatchQueue"
        ],
        correctIndex: 2,
        hint: "UI всегда работает на main thread"
    ),
    (
        question: "Что произойдет с таймером, если RunLoop остановить?",
        answers: [
            "Таймер продолжит работать",
            "Таймер сломается с ошибкой",
            "Таймер перестанет срабатывать",
            "Таймер выполнится сразу все пропущенные вызовы"
        ],
        correctIndex: 2,
        hint: "Timer зависит от RunLoop"
    ),
    (
        question: "Как добавить таймер в RunLoop вручную?",
        answers: [
            "runLoop.add(timer, forMode: .default)",
            "Timer.run(on: runLoop)",
            "DispatchQueue.main.add(timer)",
            "Timer.attachToRunLoop(runLoop)"
        ],
        correctIndex: 0,
        hint: "Нужен метод add(_:forMode:)"
    ),
    (
        question: "Как остановить повторяющийся Timer?",
        answers: [
            "timer.invalidate()",
            "timer.stop()",
            "timer.cancel()",
            "timer.close()"
        ],
        correctIndex: 0,
        hint: "Есть специальный метод invalidate"
    ),
    (
        question: "Что произойдет, если не удерживать сильную ссылку на Timer?",
        answers: [
            "Он будет автоматически работать",
            "Его автоматически перенесет в глобальный RunLoop",
            "Он будет удален сборщиком мусора и перестанет работать",
            "Он всегда работает без ссылок"
        ],
        correctIndex: 2,
        hint: "Нужно хранить Timer в свойстве, иначе он исчезнет"
    ),
    (
        question: "Что делает RunLoop mode?",
        answers: [
            "Определяет частоту срабатывания таймера",
            "Указывает, какие события RunLoop будет обрабатывать",
            "Управляет потоками",
            "Запускает задачи в GCD"
        ],
        correctIndex: 1,
        hint: "Есть default, common, tracking и другие режимы"
    ),
    (
        question: "Что произойдет, если поставить таймер в режим .commonModes?",
        answers: [
            "Он будет выполняться только на главном потоке",
            "Он не будет выполняться в режиме скролла",
            "Он будет работать в нескольких режимах RunLoop",
            "Он автоматически станет фоновым"
        ],
        correctIndex: 2,
        hint: "CommonModes включает несколько режимов одновременно"
    )
] //7
















































